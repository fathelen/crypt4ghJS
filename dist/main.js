/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@stablelib/binary/lib/binary.js":
/*!******************************************************!*\
  !*** ./node_modules/@stablelib/binary/lib/binary.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\nvar int_1 = __webpack_require__(/*! @stablelib/int */ \"./node_modules/@stablelib/int/lib/int.js\");\n// TODO(dchest): add asserts for correct value ranges and array offsets.\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;\n}\nexports.readInt16BE = readInt16BE;\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;\n}\nexports.readUint16BE = readUint16BE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\nfunction readInt16LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;\n}\nexports.readInt16LE = readInt16LE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\nfunction readUint16LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 1] << 8) | array[offset]) >>> 0;\n}\nexports.readUint16LE = readUint16LE;\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(2); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 8;\n    out[offset + 1] = value >>> 0;\n    return out;\n}\nexports.writeUint16BE = writeUint16BE;\nexports.writeInt16BE = writeUint16BE;\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint16LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(2); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    return out;\n}\nexports.writeUint16LE = writeUint16LE;\nexports.writeInt16LE = writeUint16LE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3];\n}\nexports.readInt32BE = readInt32BE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset] << 24) |\n        (array[offset + 1] << 16) |\n        (array[offset + 2] << 8) |\n        array[offset + 3]) >>> 0;\n}\nexports.readUint32BE = readUint32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\nfunction readInt32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return (array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset];\n}\nexports.readInt32LE = readInt32LE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\nfunction readUint32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    return ((array[offset + 3] << 24) |\n        (array[offset + 2] << 16) |\n        (array[offset + 1] << 8) |\n        array[offset]) >>> 0;\n}\nexports.readUint32LE = readUint32LE;\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 24;\n    out[offset + 1] = value >>> 16;\n    out[offset + 2] = value >>> 8;\n    out[offset + 3] = value >>> 0;\n    return out;\n}\nexports.writeUint32BE = writeUint32BE;\nexports.writeInt32BE = writeUint32BE;\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint32LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    out[offset + 0] = value >>> 0;\n    out[offset + 1] = value >>> 8;\n    out[offset + 2] = value >>> 16;\n    out[offset + 3] = value >>> 24;\n    return out;\n}\nexports.writeUint32LE = writeUint32LE;\nexports.writeInt32LE = writeUint32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var hi = readInt32BE(array, offset);\n    var lo = readInt32BE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);\n}\nexports.readInt64BE = readInt64BE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var hi = readUint32BE(array, offset);\n    var lo = readUint32BE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\nexports.readUint64BE = readUint64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nfunction readInt64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var lo = readInt32LE(array, offset);\n    var hi = readInt32LE(array, offset + 4);\n    return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);\n}\nexports.readInt64LE = readInt64LE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nfunction readUint64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var lo = readUint32LE(array, offset);\n    var hi = readUint32LE(array, offset + 4);\n    return hi * 0x100000000 + lo;\n}\nexports.readUint64LE = readUint64LE;\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n    writeUint32BE(value >>> 0, out, offset + 4);\n    return out;\n}\nexports.writeUint64BE = writeUint64BE;\nexports.writeInt64BE = writeUint64BE;\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeUint64LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    writeUint32LE(value >>> 0, out, offset);\n    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n    return out;\n}\nexports.writeUint64LE = writeUint64LE;\nexports.writeInt64LE = writeUint64LE;\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintBE(bitLength, array, offset) {\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintBE: array is too short for the given bitLength\");\n    }\n    var result = 0;\n    var mul = 1;\n    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\nexports.readUintBE = readUintBE;\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nfunction readUintLE(bitLength, array, offset) {\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n    }\n    if (bitLength / 8 > array.length - offset) {\n        throw new Error(\"readUintLE: array is too short for the given bitLength\");\n    }\n    var result = 0;\n    var mul = 1;\n    for (var i = offset; i < offset + bitLength / 8; i++) {\n        result += array[i] * mul;\n        mul *= 256;\n    }\n    return result;\n}\nexports.readUintLE = readUintLE;\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintBE(bitLength, value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(bitLength / 8); }\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n    }\n    if (!int_1.isSafeInteger(value)) {\n        throw new Error(\"writeUintBE value must be an integer\");\n    }\n    var div = 1;\n    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\nexports.writeUintBE = writeUintBE;\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nfunction writeUintLE(bitLength, value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(bitLength / 8); }\n    if (offset === void 0) { offset = 0; }\n    // TODO(dchest): implement support for bitLengths non-divisible by 8\n    if (bitLength % 8 !== 0) {\n        throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n    }\n    if (!int_1.isSafeInteger(value)) {\n        throw new Error(\"writeUintLE value must be an integer\");\n    }\n    var div = 1;\n    for (var i = offset; i < offset + bitLength / 8; i++) {\n        out[i] = (value / div) & 0xff;\n        div *= 256;\n    }\n    return out;\n}\nexports.writeUintLE = writeUintLE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset);\n}\nexports.readFloat32BE = readFloat32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\nfunction readFloat32LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat32(offset, true);\n}\nexports.readFloat32LE = readFloat32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64BE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset);\n}\nexports.readFloat64BE = readFloat64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\nfunction readFloat64LE(array, offset) {\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n    return view.getFloat64(offset, true);\n}\nexports.readFloat64LE = readFloat64LE;\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value);\n    return out;\n}\nexports.writeFloat32BE = writeFloat32BE;\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat32LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(4); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat32(offset, value, true);\n    return out;\n}\nexports.writeFloat32LE = writeFloat32LE;\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64BE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value);\n    return out;\n}\nexports.writeFloat64BE = writeFloat64BE;\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nfunction writeFloat64LE(value, out, offset) {\n    if (out === void 0) { out = new Uint8Array(8); }\n    if (offset === void 0) { offset = 0; }\n    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n    view.setFloat64(offset, value, true);\n    return out;\n}\nexports.writeFloat64LE = writeFloat64LE;\n//# sourceMappingURL=binary.js.map\n\n//# sourceURL=webpack://crypt4gh_js/./node_modules/@stablelib/binary/lib/binary.js?");

/***/ }),

/***/ "./node_modules/@stablelib/blake2b/lib/blake2b.js":
/*!********************************************************!*\
  !*** ./node_modules/@stablelib/blake2b/lib/blake2b.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2017 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar binary_1 = __webpack_require__(/*! @stablelib/binary */ \"./node_modules/@stablelib/binary/lib/binary.js\");\nvar wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"./node_modules/@stablelib/wipe/lib/wipe.js\");\nexports.BLOCK_SIZE = 128;\nexports.DIGEST_LENGTH = 64;\nexports.KEY_LENGTH = 64;\nexports.PERSONALIZATION_LENGTH = 16;\nexports.SALT_LENGTH = 16;\nexports.MAX_LEAF_SIZE = Math.pow(2, 32) - 1;\nexports.MAX_FANOUT = 255;\nexports.MAX_MAX_DEPTH = 255; // not a typo\nvar IV = new Uint32Array([\n    // low bits // high bits\n    0xf3bcc908, 0x6a09e667,\n    0x84caa73b, 0xbb67ae85,\n    0xfe94f82b, 0x3c6ef372,\n    0x5f1d36f1, 0xa54ff53a,\n    0xade682d1, 0x510e527f,\n    0x2b3e6c1f, 0x9b05688c,\n    0xfb41bd6b, 0x1f83d9ab,\n    0x137e2179, 0x5be0cd19,\n]);\n// Note: sigma values are doubled since we store\n// 64-bit ints as two 32-bit ints in arrays.\nvar SIGMA = [\n    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],\n    [28, 20, 8, 16, 18, 30, 26, 12, 2, 24, 0, 4, 22, 14, 10, 6],\n    [22, 16, 24, 0, 10, 4, 30, 26, 20, 28, 6, 12, 14, 2, 18, 8],\n    [14, 18, 6, 2, 26, 24, 22, 28, 4, 12, 10, 20, 8, 0, 30, 16],\n    [18, 0, 10, 14, 4, 8, 20, 30, 28, 2, 22, 24, 12, 16, 6, 26],\n    [4, 24, 12, 20, 0, 22, 16, 6, 8, 26, 14, 10, 30, 28, 2, 18],\n    [24, 10, 2, 30, 28, 26, 8, 20, 0, 14, 12, 6, 18, 4, 16, 22],\n    [26, 22, 14, 28, 24, 2, 6, 18, 10, 0, 30, 8, 16, 12, 4, 20],\n    [12, 30, 28, 18, 22, 6, 0, 16, 24, 4, 26, 14, 2, 8, 20, 10],\n    [20, 4, 16, 8, 14, 12, 2, 10, 30, 22, 18, 28, 6, 24, 26, 0],\n    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],\n    [28, 20, 8, 16, 18, 30, 26, 12, 2, 24, 0, 4, 22, 14, 10, 6]\n];\n/**\n * BLAKE2b hash function.\n */\nvar BLAKE2b = /** @class */ (function () {\n    function BLAKE2b(digestLength, config) {\n        if (digestLength === void 0) { digestLength = 64; }\n        this.digestLength = digestLength;\n        this.blockSize = exports.BLOCK_SIZE;\n        // Note: Int32Arrays for state and message are used for performance reasons.\n        this._state = new Int32Array(IV); // hash state, initialized with IV\n        this._buffer = new Uint8Array(exports.BLOCK_SIZE); // buffer for data\n        this._bufferLength = 0; // number of bytes in buffer\n        this._ctr = new Uint32Array(4);\n        this._flag = new Uint32Array(4);\n        this._lastNode = false;\n        this._finished = false;\n        this._vtmp = new Uint32Array(32);\n        this._mtmp = new Uint32Array(32);\n        // Validate digest length.\n        if (digestLength < 1 || digestLength > exports.DIGEST_LENGTH) {\n            throw new Error(\"blake2b: wrong digest length\");\n        }\n        // Validate config, if present.\n        if (config) {\n            this.validateConfig(config);\n        }\n        // Get key length from config.\n        var keyLength = 0;\n        if (config && config.key) {\n            keyLength = config.key.length;\n        }\n        // Get tree fanout and maxDepth from config.\n        var fanout = 1;\n        var maxDepth = 1;\n        if (config && config.tree) {\n            fanout = config.tree.fanout;\n            maxDepth = config.tree.maxDepth;\n        }\n        // Xor common parameters into state.\n        this._state[0] ^= digestLength | (keyLength << 8) | (fanout << 16) | (maxDepth << 24);\n        // Xor tree parameters into state.\n        if (config && config.tree) {\n            this._state[1] ^= config.tree.leafSize;\n            this._state[2] ^= config.tree.nodeOffsetLowBits;\n            this._state[3] ^= config.tree.nodeOffsetHighBits;\n            this._state[4] ^= config.tree.nodeDepth | (config.tree.innerDigestLength << 8);\n            this._lastNode = config.tree.lastNode;\n        }\n        // Xor salt into state.\n        if (config && config.salt) {\n            this._state[8] ^= binary_1.readUint32LE(config.salt, 0);\n            this._state[9] ^= binary_1.readUint32LE(config.salt, 4);\n            this._state[10] ^= binary_1.readUint32LE(config.salt, 8);\n            this._state[11] ^= binary_1.readUint32LE(config.salt, 12);\n        }\n        // Xor personalization into state.\n        if (config && config.personalization) {\n            this._state[12] ^= binary_1.readUint32LE(config.personalization, 0);\n            this._state[13] ^= binary_1.readUint32LE(config.personalization, 4);\n            this._state[14] ^= binary_1.readUint32LE(config.personalization, 8);\n            this._state[15] ^= binary_1.readUint32LE(config.personalization, 12);\n        }\n        // Save a copy of initialized state for reset.\n        this._initialState = new Uint32Array(this._state);\n        // Process key.\n        if (config && config.key && keyLength > 0) {\n            this._paddedKey = new Uint8Array(exports.BLOCK_SIZE);\n            this._paddedKey.set(config.key);\n            // Put padded key into buffer.\n            this._buffer.set(this._paddedKey);\n            this._bufferLength = exports.BLOCK_SIZE;\n        }\n    }\n    BLAKE2b.prototype.reset = function () {\n        // Restore initial state.\n        this._state.set(this._initialState);\n        if (this._paddedKey) {\n            // Put padded key into buffer.\n            this._buffer.set(this._paddedKey);\n            this._bufferLength = exports.BLOCK_SIZE;\n        }\n        else {\n            this._bufferLength = 0;\n        }\n        // Clear counters and flags.\n        wipe_1.wipe(this._ctr);\n        wipe_1.wipe(this._flag);\n        this._finished = false;\n        return this;\n    };\n    BLAKE2b.prototype.validateConfig = function (config) {\n        if (config.key && config.key.length > exports.KEY_LENGTH) {\n            throw new Error(\"blake2b: wrong key length\");\n        }\n        if (config.salt && config.salt.length !== exports.SALT_LENGTH) {\n            throw new Error(\"blake2b: wrong salt length\");\n        }\n        if (config.personalization &&\n            config.personalization.length !== exports.PERSONALIZATION_LENGTH) {\n            throw new Error(\"blake2b: wrong personalization length\");\n        }\n        if (config.tree) {\n            if (config.tree.fanout < 0 || config.tree.fanout > exports.MAX_FANOUT) {\n                throw new Error(\"blake2b: wrong tree fanout\");\n            }\n            if (config.tree.maxDepth < 0 || config.tree.maxDepth > exports.MAX_MAX_DEPTH) {\n                throw new Error(\"blake2b: wrong tree depth\");\n            }\n            if (config.tree.leafSize < 0 || config.tree.leafSize > exports.MAX_LEAF_SIZE) {\n                throw new Error(\"blake2b: wrong leaf size\");\n            }\n            if (config.tree.innerDigestLength < 0 ||\n                config.tree.innerDigestLength > exports.DIGEST_LENGTH) {\n                throw new Error(\"blake2b: wrong tree inner digest length\");\n            }\n        }\n    };\n    BLAKE2b.prototype.update = function (data, dataLength) {\n        if (dataLength === void 0) { dataLength = data.length; }\n        if (this._finished) {\n            throw new Error(\"blake2b: can't update because hash was finished.\");\n        }\n        var left = exports.BLOCK_SIZE - this._bufferLength;\n        var dataPos = 0;\n        if (dataLength === 0) {\n            return this;\n        }\n        // Finish buffer.\n        if (dataLength > left) {\n            for (var i = 0; i < left; i++) {\n                this._buffer[this._bufferLength + i] = data[dataPos + i];\n            }\n            this._processBlock(exports.BLOCK_SIZE);\n            dataPos += left;\n            dataLength -= left;\n            this._bufferLength = 0;\n        }\n        // Process data blocks.\n        while (dataLength > exports.BLOCK_SIZE) {\n            for (var i = 0; i < exports.BLOCK_SIZE; i++) {\n                this._buffer[i] = data[dataPos + i];\n            }\n            this._processBlock(exports.BLOCK_SIZE);\n            dataPos += exports.BLOCK_SIZE;\n            dataLength -= exports.BLOCK_SIZE;\n            this._bufferLength = 0;\n        }\n        // Copy leftovers to buffer.\n        for (var i = 0; i < dataLength; i++) {\n            this._buffer[this._bufferLength + i] = data[dataPos + i];\n        }\n        this._bufferLength += dataLength;\n        return this;\n    };\n    BLAKE2b.prototype.finish = function (out) {\n        if (!this._finished) {\n            for (var i = this._bufferLength; i < exports.BLOCK_SIZE; i++) {\n                this._buffer[i] = 0;\n            }\n            // Set last block flag.\n            this._flag[0] = 0xffffffff;\n            this._flag[1] = 0xffffffff;\n            // Set last node flag if last node in tree.\n            if (this._lastNode) {\n                this._flag[2] = 0xffffffff;\n                this._flag[3] = 0xffffffff;\n            }\n            this._processBlock(this._bufferLength);\n            this._finished = true;\n        }\n        // Reuse buffer as temporary space for digest.\n        var tmp = this._buffer.subarray(0, 64);\n        for (var i = 0; i < 16; i++) {\n            binary_1.writeUint32LE(this._state[i], tmp, i * 4);\n        }\n        out.set(tmp.subarray(0, out.length));\n        return this;\n    };\n    BLAKE2b.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    BLAKE2b.prototype.clean = function () {\n        wipe_1.wipe(this._vtmp);\n        wipe_1.wipe(this._mtmp);\n        wipe_1.wipe(this._state);\n        wipe_1.wipe(this._buffer);\n        wipe_1.wipe(this._initialState);\n        if (this._paddedKey) {\n            wipe_1.wipe(this._paddedKey);\n        }\n        this._bufferLength = 0;\n        wipe_1.wipe(this._ctr);\n        wipe_1.wipe(this._flag);\n        this._lastNode = false;\n        this._finished = false;\n    };\n    BLAKE2b.prototype.saveState = function () {\n        if (this._finished) {\n            throw new Error(\"blake2b: cannot save finished state\");\n        }\n        return {\n            state: new Uint32Array(this._state),\n            buffer: new Uint8Array(this._buffer),\n            bufferLength: this._bufferLength,\n            ctr: new Uint32Array(this._ctr),\n            flag: new Uint32Array(this._flag),\n            lastNode: this._lastNode,\n            paddedKey: this._paddedKey ? new Uint8Array(this._paddedKey) : undefined,\n            initialState: new Uint32Array(this._initialState)\n        };\n    };\n    BLAKE2b.prototype.restoreState = function (savedState) {\n        this._state.set(savedState.state);\n        this._buffer.set(savedState.buffer);\n        this._bufferLength = savedState.bufferLength;\n        this._ctr.set(savedState.ctr);\n        this._flag.set(savedState.flag);\n        this._lastNode = savedState.lastNode;\n        if (this._paddedKey) {\n            wipe_1.wipe(this._paddedKey);\n        }\n        this._paddedKey = savedState.paddedKey ? new Uint8Array(savedState.paddedKey) : undefined;\n        this._initialState.set(savedState.initialState);\n        return this;\n    };\n    BLAKE2b.prototype.cleanSavedState = function (savedState) {\n        wipe_1.wipe(savedState.state);\n        wipe_1.wipe(savedState.buffer);\n        wipe_1.wipe(savedState.initialState);\n        if (savedState.paddedKey) {\n            wipe_1.wipe(savedState.paddedKey);\n        }\n        savedState.bufferLength = 0;\n        wipe_1.wipe(savedState.ctr);\n        wipe_1.wipe(savedState.flag);\n        savedState.lastNode = false;\n    };\n    BLAKE2b.prototype._G = function (v, al, bl, cl, dl, ah, bh, ch, dh, ml0, mh0, ml1, mh1) {\n        var vla = v[al], vha = v[ah], vlb = v[bl], vhb = v[bh], vlc = v[cl], vhc = v[ch], vld = v[dl], vhd = v[dh];\n        // 64-bit: va += vb\n        var w = vla & 0xffff, x = vla >>> 16, y = vha & 0xffff, z = vha >>> 16;\n        w += vlb & 0xffff;\n        x += vlb >>> 16;\n        y += vhb & 0xffff;\n        z += vhb >>> 16;\n        x += w >>> 16;\n        y += x >>> 16;\n        z += y >>> 16;\n        vha = (y & 0xffff) | (z << 16);\n        vla = (w & 0xffff) | (x << 16);\n        // 64-bit: va += m[sigma[r][2 * i + 0]]\n        w = vla & 0xffff;\n        x = vla >>> 16;\n        y = vha & 0xffff;\n        z = vha >>> 16;\n        w += ml0 & 0xffff;\n        x += ml0 >>> 16;\n        y += mh0 & 0xffff;\n        z += mh0 >>> 16;\n        x += w >>> 16;\n        y += x >>> 16;\n        z += y >>> 16;\n        vha = (y & 0xffff) | (z << 16);\n        vla = (w & 0xffff) | (x << 16);\n        // 64-bit: vd ^= va\n        vld ^= vla;\n        vhd ^= vha;\n        // 64-bit: rot(vd, 32)\n        w = vhd;\n        vhd = vld;\n        vld = w;\n        // 64-bit: vc += vd\n        w = vlc & 0xffff;\n        x = vlc >>> 16;\n        y = vhc & 0xffff;\n        z = vhc >>> 16;\n        w += vld & 0xffff;\n        x += vld >>> 16;\n        y += vhd & 0xffff;\n        z += vhd >>> 16;\n        x += w >>> 16;\n        y += x >>> 16;\n        z += y >>> 16;\n        vhc = (y & 0xffff) | (z << 16);\n        vlc = (w & 0xffff) | (x << 16);\n        // 64-bit: vb ^= vc\n        vlb ^= vlc;\n        vhb ^= vhc;\n        // 64-bit: rot(vb, 24)\n        w = vlb << 8 | vhb >>> 24;\n        vlb = vhb << 8 | vlb >>> 24;\n        vhb = w;\n        // 64-bit: va += vb\n        w = vla & 0xffff;\n        x = vla >>> 16;\n        y = vha & 0xffff;\n        z = vha >>> 16;\n        w += vlb & 0xffff;\n        x += vlb >>> 16;\n        y += vhb & 0xffff;\n        z += vhb >>> 16;\n        x += w >>> 16;\n        y += x >>> 16;\n        z += y >>> 16;\n        vha = (y & 0xffff) | (z << 16);\n        vla = (w & 0xffff) | (x << 16);\n        // 64-bit: va += m[sigma[r][2 * i + 1]\n        w = vla & 0xffff;\n        x = vla >>> 16;\n        y = vha & 0xffff;\n        z = vha >>> 16;\n        w += ml1 & 0xffff;\n        x += ml1 >>> 16;\n        y += mh1 & 0xffff;\n        z += mh1 >>> 16;\n        x += w >>> 16;\n        y += x >>> 16;\n        z += y >>> 16;\n        vha = (y & 0xffff) | (z << 16);\n        vla = (w & 0xffff) | (x << 16);\n        // 64-bit: vd ^= va\n        vld ^= vla;\n        vhd ^= vha;\n        // 64-bit: rot(vd, 16)\n        w = vld << 16 | vhd >>> 16;\n        vld = vhd << 16 | vld >>> 16;\n        vhd = w;\n        // 64-bit: vc += vd\n        w = vlc & 0xffff;\n        x = vlc >>> 16;\n        y = vhc & 0xffff;\n        z = vhc >>> 16;\n        w += vld & 0xffff;\n        x += vld >>> 16;\n        y += vhd & 0xffff;\n        z += vhd >>> 16;\n        x += w >>> 16;\n        y += x >>> 16;\n        z += y >>> 16;\n        vhc = (y & 0xffff) | (z << 16);\n        vlc = (w & 0xffff) | (x << 16);\n        // 64-bit: vb ^= vc\n        vlb ^= vlc;\n        vhb ^= vhc;\n        // 64-bit: rot(vb, 63)\n        w = vhb << 1 | vlb >>> 31;\n        vlb = vlb << 1 | vhb >>> 31;\n        vhb = w;\n        v[al] = vla;\n        v[ah] = vha;\n        v[bl] = vlb;\n        v[bh] = vhb;\n        v[cl] = vlc;\n        v[ch] = vhc;\n        v[dl] = vld;\n        v[dh] = vhd;\n    };\n    BLAKE2b.prototype._incrementCounter = function (n) {\n        for (var i = 0; i < 3; i++) {\n            var a = this._ctr[i] + n;\n            this._ctr[i] = a >>> 0;\n            if (this._ctr[i] === a) {\n                return;\n            }\n            n = 1;\n        }\n    };\n    BLAKE2b.prototype._processBlock = function (length) {\n        this._incrementCounter(length);\n        var v = this._vtmp;\n        v.set(this._state);\n        v.set(IV, 16);\n        v[12 * 2 + 0] ^= this._ctr[0];\n        v[12 * 2 + 1] ^= this._ctr[1];\n        v[13 * 2 + 0] ^= this._ctr[2];\n        v[13 * 2 + 1] ^= this._ctr[3];\n        v[14 * 2 + 0] ^= this._flag[0];\n        v[14 * 2 + 1] ^= this._flag[1];\n        v[15 * 2 + 0] ^= this._flag[2];\n        v[15 * 2 + 1] ^= this._flag[3];\n        var m = this._mtmp;\n        for (var i = 0; i < 32; i++) {\n            m[i] = binary_1.readUint32LE(this._buffer, i * 4);\n        }\n        for (var r = 0; r < 12; r++) {\n            this._G(v, 0, 8, 16, 24, 1, 9, 17, 25, m[SIGMA[r][0]], m[SIGMA[r][0] + 1], m[SIGMA[r][1]], m[SIGMA[r][1] + 1]);\n            this._G(v, 2, 10, 18, 26, 3, 11, 19, 27, m[SIGMA[r][2]], m[SIGMA[r][2] + 1], m[SIGMA[r][3]], m[SIGMA[r][3] + 1]);\n            this._G(v, 4, 12, 20, 28, 5, 13, 21, 29, m[SIGMA[r][4]], m[SIGMA[r][4] + 1], m[SIGMA[r][5]], m[SIGMA[r][5] + 1]);\n            this._G(v, 6, 14, 22, 30, 7, 15, 23, 31, m[SIGMA[r][6]], m[SIGMA[r][6] + 1], m[SIGMA[r][7]], m[SIGMA[r][7] + 1]);\n            this._G(v, 0, 10, 20, 30, 1, 11, 21, 31, m[SIGMA[r][8]], m[SIGMA[r][8] + 1], m[SIGMA[r][9]], m[SIGMA[r][9] + 1]);\n            this._G(v, 2, 12, 22, 24, 3, 13, 23, 25, m[SIGMA[r][10]], m[SIGMA[r][10] + 1], m[SIGMA[r][11]], m[SIGMA[r][11] + 1]);\n            this._G(v, 4, 14, 16, 26, 5, 15, 17, 27, m[SIGMA[r][12]], m[SIGMA[r][12] + 1], m[SIGMA[r][13]], m[SIGMA[r][13] + 1]);\n            this._G(v, 6, 8, 18, 28, 7, 9, 19, 29, m[SIGMA[r][14]], m[SIGMA[r][14] + 1], m[SIGMA[r][15]], m[SIGMA[r][15] + 1]);\n        }\n        for (var i = 0; i < 16; i++) {\n            this._state[i] ^= v[i] ^ v[i + 16];\n        }\n    };\n    return BLAKE2b;\n}());\nexports.BLAKE2b = BLAKE2b;\nfunction hash(data, digestLength, config) {\n    if (digestLength === void 0) { digestLength = exports.DIGEST_LENGTH; }\n    var h = new BLAKE2b(digestLength, config);\n    h.update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hash = hash;\n//# sourceMappingURL=blake2b.js.map\n\n//# sourceURL=webpack://crypt4gh_js/./node_modules/@stablelib/blake2b/lib/blake2b.js?");

/***/ }),

/***/ "./node_modules/@stablelib/int/lib/int.js":
/*!************************************************!*\
  !*** ./node_modules/@stablelib/int/lib/int.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Package int provides helper functions for integerss.\n */\n// Shim using 16-bit pieces.\nfunction imulShim(a, b) {\n    var ah = (a >>> 16) & 0xffff, al = a & 0xffff;\n    var bh = (b >>> 16) & 0xffff, bl = b & 0xffff;\n    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n}\n/** 32-bit integer multiplication.  */\n// Use system Math.imul if available, otherwise use our shim.\nexports.mul = Math.imul || imulShim;\n/** 32-bit integer addition.  */\nfunction add(a, b) {\n    return (a + b) | 0;\n}\nexports.add = add;\n/**  32-bit integer subtraction.  */\nfunction sub(a, b) {\n    return (a - b) | 0;\n}\nexports.sub = sub;\n/** 32-bit integer left rotation */\nfunction rotl(x, n) {\n    return x << n | x >>> (32 - n);\n}\nexports.rotl = rotl;\n/** 32-bit integer left rotation */\nfunction rotr(x, n) {\n    return x << (32 - n) | x >>> n;\n}\nexports.rotr = rotr;\nfunction isIntegerShim(n) {\n    return typeof n === \"number\" && isFinite(n) && Math.floor(n) === n;\n}\n/**\n * Returns true if the argument is an integer number.\n *\n * In ES2015, Number.isInteger.\n */\nexports.isInteger = Number.isInteger || isIntegerShim;\n/**\n *  Math.pow(2, 53) - 1\n *\n *  In ES2015 Number.MAX_SAFE_INTEGER.\n */\nexports.MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * Returns true if the argument is a safe integer number\n * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)\n *\n * In ES2015, Number.isSafeInteger.\n */\nexports.isSafeInteger = function (n) {\n    return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);\n};\n//# sourceMappingURL=int.js.map\n\n//# sourceURL=webpack://crypt4gh_js/./node_modules/@stablelib/int/lib/int.js?");

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/random.js":
/*!******************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/random.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;\nconst system_1 = __webpack_require__(/*! ./source/system */ \"./node_modules/@stablelib/random/lib/source/system.js\");\nconst binary_1 = __webpack_require__(/*! @stablelib/binary */ \"./node_modules/@stablelib/binary/lib/binary.js\");\nconst wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"./node_modules/@stablelib/wipe/lib/wipe.js\");\nexports.defaultRandomSource = new system_1.SystemRandomSource();\nfunction randomBytes(length, prng = exports.defaultRandomSource) {\n    return prng.randomBytes(length);\n}\nexports.randomBytes = randomBytes;\n/**\n * Returns a uniformly random unsigned 32-bit integer.\n */\nfunction randomUint32(prng = exports.defaultRandomSource) {\n    // Generate 4-byte random buffer.\n    const buf = randomBytes(4, prng);\n    // Convert bytes from buffer into a 32-bit integer.\n    // It's not important which byte order to use, since\n    // the result is random.\n    const result = (0, binary_1.readUint32LE)(buf);\n    // Clean the buffer.\n    (0, wipe_1.wipe)(buf);\n    return result;\n}\nexports.randomUint32 = randomUint32;\n/** 62 alphanumeric characters for default charset of randomString() */\nconst ALPHANUMERIC = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n/**\n * Returns a uniform random string of the given length\n * with characters from the given charset.\n *\n * Charset must not have more than 256 characters.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nfunction randomString(length, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {\n    if (charset.length < 2) {\n        throw new Error(\"randomString charset is too short\");\n    }\n    if (charset.length > 256) {\n        throw new Error(\"randomString charset is too long\");\n    }\n    let out = '';\n    const charsLen = charset.length;\n    const maxByte = 256 - (256 % charsLen);\n    while (length > 0) {\n        const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);\n        for (let i = 0; i < buf.length && length > 0; i++) {\n            const randomByte = buf[i];\n            if (randomByte < maxByte) {\n                out += charset.charAt(randomByte % charsLen);\n                length--;\n            }\n        }\n        (0, wipe_1.wipe)(buf);\n    }\n    return out;\n}\nexports.randomString = randomString;\n/**\n * Returns uniform random string containing at least the given\n * number of bits of entropy.\n *\n * For example, randomStringForEntropy(128) will return a 22-character\n * alphanumeric string, while randomStringForEntropy(128, \"0123456789\")\n * will return a 39-character numeric string, both will contain at\n * least 128 bits of entropy.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nfunction randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {\n    const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));\n    return randomString(length, charset, prng);\n}\nexports.randomStringForEntropy = randomStringForEntropy;\n//# sourceMappingURL=random.js.map\n\n//# sourceURL=webpack://crypt4gh_js/./node_modules/@stablelib/random/lib/random.js?");

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/source/browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/source/browser.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BrowserRandomSource = void 0;\nconst QUOTA = 65536;\nclass BrowserRandomSource {\n    constructor() {\n        this.isAvailable = false;\n        this.isInstantiated = false;\n        const browserCrypto = typeof self !== 'undefined'\n            ? (self.crypto || self.msCrypto) // IE11 has msCrypto\n            : null;\n        if (browserCrypto && browserCrypto.getRandomValues !== undefined) {\n            this._crypto = browserCrypto;\n            this.isAvailable = true;\n            this.isInstantiated = true;\n        }\n    }\n    randomBytes(length) {\n        if (!this.isAvailable || !this._crypto) {\n            throw new Error(\"Browser random byte generator is not available.\");\n        }\n        const out = new Uint8Array(length);\n        for (let i = 0; i < out.length; i += QUOTA) {\n            this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));\n        }\n        return out;\n    }\n}\nexports.BrowserRandomSource = BrowserRandomSource;\n//# sourceMappingURL=browser.js.map\n\n//# sourceURL=webpack://crypt4gh_js/./node_modules/@stablelib/random/lib/source/browser.js?");

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/source/node.js":
/*!***********************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/source/node.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NodeRandomSource = void 0;\nconst wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"./node_modules/@stablelib/wipe/lib/wipe.js\");\nclass NodeRandomSource {\n    constructor() {\n        this.isAvailable = false;\n        this.isInstantiated = false;\n        if (true) {\n            const nodeCrypto = __webpack_require__(/*! crypto */ \"?25ed\");\n            if (nodeCrypto && nodeCrypto.randomBytes) {\n                this._crypto = nodeCrypto;\n                this.isAvailable = true;\n                this.isInstantiated = true;\n            }\n        }\n    }\n    randomBytes(length) {\n        if (!this.isAvailable || !this._crypto) {\n            throw new Error(\"Node.js random byte generator is not available.\");\n        }\n        // Get random bytes (result is Buffer).\n        let buffer = this._crypto.randomBytes(length);\n        // Make sure we got the length that we requested.\n        if (buffer.length !== length) {\n            throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n        }\n        // Allocate output array.\n        const out = new Uint8Array(length);\n        // Copy bytes from buffer to output.\n        for (let i = 0; i < out.length; i++) {\n            out[i] = buffer[i];\n        }\n        // Cleanup.\n        (0, wipe_1.wipe)(buffer);\n        return out;\n    }\n}\nexports.NodeRandomSource = NodeRandomSource;\n//# sourceMappingURL=node.js.map\n\n//# sourceURL=webpack://crypt4gh_js/./node_modules/@stablelib/random/lib/source/node.js?");

/***/ }),

/***/ "./node_modules/@stablelib/random/lib/source/system.js":
/*!*************************************************************!*\
  !*** ./node_modules/@stablelib/random/lib/source/system.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SystemRandomSource = void 0;\nconst browser_1 = __webpack_require__(/*! ./browser */ \"./node_modules/@stablelib/random/lib/source/browser.js\");\nconst node_1 = __webpack_require__(/*! ./node */ \"./node_modules/@stablelib/random/lib/source/node.js\");\nclass SystemRandomSource {\n    constructor() {\n        this.isAvailable = false;\n        this.name = \"\";\n        // Try browser.\n        this._source = new browser_1.BrowserRandomSource();\n        if (this._source.isAvailable) {\n            this.isAvailable = true;\n            this.name = \"Browser\";\n            return;\n        }\n        // If no browser source, try Node.\n        this._source = new node_1.NodeRandomSource();\n        if (this._source.isAvailable) {\n            this.isAvailable = true;\n            this.name = \"Node\";\n            return;\n        }\n        // No sources, we're out of options.\n    }\n    randomBytes(length) {\n        if (!this.isAvailable) {\n            throw new Error(\"System random byte generator is not available.\");\n        }\n        return this._source.randomBytes(length);\n    }\n}\nexports.SystemRandomSource = SystemRandomSource;\n//# sourceMappingURL=system.js.map\n\n//# sourceURL=webpack://crypt4gh_js/./node_modules/@stablelib/random/lib/source/system.js?");

/***/ }),

/***/ "./node_modules/@stablelib/wipe/lib/wipe.js":
/*!**************************************************!*\
  !*** ./node_modules/@stablelib/wipe/lib/wipe.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Sets all values in the given array to zero and returns it.\n *\n * The fact that it sets bytes to zero can be relied on.\n *\n * There is no guarantee that this function makes data disappear from memory,\n * as runtime implementation can, for example, have copying garbage collector\n * that will make copies of sensitive data before we wipe it. Or that an\n * operating system will write our data to swap or sleep image. Another thing\n * is that an optimizing compiler can remove calls to this function or make it\n * no-op. There's nothing we can do with it, so we just do our best and hope\n * that everything will be okay and good will triumph over evil.\n */\nfunction wipe(array) {\n    // Right now it's similar to array.fill(0). If it turns\n    // out that runtimes optimize this call away, maybe\n    // we can try something else.\n    for (var i = 0; i < array.length; i++) {\n        array[i] = 0;\n    }\n    return array;\n}\nexports.wipe = wipe;\n//# sourceMappingURL=wipe.js.map\n\n//# sourceURL=webpack://crypt4gh_js/./node_modules/@stablelib/wipe/lib/wipe.js?");

/***/ }),

/***/ "./node_modules/@stablelib/x25519/lib/x25519.js":
/*!******************************************************!*\
  !*** ./node_modules/@stablelib/x25519/lib/x25519.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;\n/**\n * Package x25519 implements X25519 key agreement.\n */\nconst random_1 = __webpack_require__(/*! @stablelib/random */ \"./node_modules/@stablelib/random/lib/random.js\");\nconst wipe_1 = __webpack_require__(/*! @stablelib/wipe */ \"./node_modules/@stablelib/wipe/lib/wipe.js\");\nexports.PUBLIC_KEY_LENGTH = 32;\nexports.SECRET_KEY_LENGTH = 32;\nexports.SHARED_KEY_LENGTH = 32;\n// Returns new zero-filled 16-element GF (Float64Array).\n// If passed an array of numbers, prefills the returned\n// array with them.\n//\n// We use Float64Array, because we need 48-bit numbers\n// for this implementation.\nfunction gf(init) {\n    const r = new Float64Array(16);\n    if (init) {\n        for (let i = 0; i < init.length; i++) {\n            r[i] = init[i];\n        }\n    }\n    return r;\n}\n// Base point.\nconst _9 = new Uint8Array(32);\n_9[0] = 9;\nconst _121665 = gf([0xdb41, 1]);\nfunction car25519(o) {\n    let c = 1;\n    for (let i = 0; i < 16; i++) {\n        let v = o[i] + c + 65535;\n        c = Math.floor(v / 65536);\n        o[i] = v - c * 65536;\n    }\n    o[0] += c - 1 + 37 * (c - 1);\n}\nfunction sel25519(p, q, b) {\n    const c = ~(b - 1);\n    for (let i = 0; i < 16; i++) {\n        const t = c & (p[i] ^ q[i]);\n        p[i] ^= t;\n        q[i] ^= t;\n    }\n}\nfunction pack25519(o, n) {\n    const m = gf();\n    const t = gf();\n    for (let i = 0; i < 16; i++) {\n        t[i] = n[i];\n    }\n    car25519(t);\n    car25519(t);\n    car25519(t);\n    for (let j = 0; j < 2; j++) {\n        m[0] = t[0] - 0xffed;\n        for (let i = 1; i < 15; i++) {\n            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);\n            m[i - 1] &= 0xffff;\n        }\n        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);\n        const b = (m[15] >> 16) & 1;\n        m[14] &= 0xffff;\n        sel25519(t, m, 1 - b);\n    }\n    for (let i = 0; i < 16; i++) {\n        o[2 * i] = t[i] & 0xff;\n        o[2 * i + 1] = t[i] >> 8;\n    }\n}\nfunction unpack25519(o, n) {\n    for (let i = 0; i < 16; i++) {\n        o[i] = n[2 * i] + (n[2 * i + 1] << 8);\n    }\n    o[15] &= 0x7fff;\n}\nfunction add(o, a, b) {\n    for (let i = 0; i < 16; i++) {\n        o[i] = a[i] + b[i];\n    }\n}\nfunction sub(o, a, b) {\n    for (let i = 0; i < 16; i++) {\n        o[i] = a[i] - b[i];\n    }\n}\nfunction mul(o, a, b) {\n    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];\n    v = a[0];\n    t0 += v * b0;\n    t1 += v * b1;\n    t2 += v * b2;\n    t3 += v * b3;\n    t4 += v * b4;\n    t5 += v * b5;\n    t6 += v * b6;\n    t7 += v * b7;\n    t8 += v * b8;\n    t9 += v * b9;\n    t10 += v * b10;\n    t11 += v * b11;\n    t12 += v * b12;\n    t13 += v * b13;\n    t14 += v * b14;\n    t15 += v * b15;\n    v = a[1];\n    t1 += v * b0;\n    t2 += v * b1;\n    t3 += v * b2;\n    t4 += v * b3;\n    t5 += v * b4;\n    t6 += v * b5;\n    t7 += v * b6;\n    t8 += v * b7;\n    t9 += v * b8;\n    t10 += v * b9;\n    t11 += v * b10;\n    t12 += v * b11;\n    t13 += v * b12;\n    t14 += v * b13;\n    t15 += v * b14;\n    t16 += v * b15;\n    v = a[2];\n    t2 += v * b0;\n    t3 += v * b1;\n    t4 += v * b2;\n    t5 += v * b3;\n    t6 += v * b4;\n    t7 += v * b5;\n    t8 += v * b6;\n    t9 += v * b7;\n    t10 += v * b8;\n    t11 += v * b9;\n    t12 += v * b10;\n    t13 += v * b11;\n    t14 += v * b12;\n    t15 += v * b13;\n    t16 += v * b14;\n    t17 += v * b15;\n    v = a[3];\n    t3 += v * b0;\n    t4 += v * b1;\n    t5 += v * b2;\n    t6 += v * b3;\n    t7 += v * b4;\n    t8 += v * b5;\n    t9 += v * b6;\n    t10 += v * b7;\n    t11 += v * b8;\n    t12 += v * b9;\n    t13 += v * b10;\n    t14 += v * b11;\n    t15 += v * b12;\n    t16 += v * b13;\n    t17 += v * b14;\n    t18 += v * b15;\n    v = a[4];\n    t4 += v * b0;\n    t5 += v * b1;\n    t6 += v * b2;\n    t7 += v * b3;\n    t8 += v * b4;\n    t9 += v * b5;\n    t10 += v * b6;\n    t11 += v * b7;\n    t12 += v * b8;\n    t13 += v * b9;\n    t14 += v * b10;\n    t15 += v * b11;\n    t16 += v * b12;\n    t17 += v * b13;\n    t18 += v * b14;\n    t19 += v * b15;\n    v = a[5];\n    t5 += v * b0;\n    t6 += v * b1;\n    t7 += v * b2;\n    t8 += v * b3;\n    t9 += v * b4;\n    t10 += v * b5;\n    t11 += v * b6;\n    t12 += v * b7;\n    t13 += v * b8;\n    t14 += v * b9;\n    t15 += v * b10;\n    t16 += v * b11;\n    t17 += v * b12;\n    t18 += v * b13;\n    t19 += v * b14;\n    t20 += v * b15;\n    v = a[6];\n    t6 += v * b0;\n    t7 += v * b1;\n    t8 += v * b2;\n    t9 += v * b3;\n    t10 += v * b4;\n    t11 += v * b5;\n    t12 += v * b6;\n    t13 += v * b7;\n    t14 += v * b8;\n    t15 += v * b9;\n    t16 += v * b10;\n    t17 += v * b11;\n    t18 += v * b12;\n    t19 += v * b13;\n    t20 += v * b14;\n    t21 += v * b15;\n    v = a[7];\n    t7 += v * b0;\n    t8 += v * b1;\n    t9 += v * b2;\n    t10 += v * b3;\n    t11 += v * b4;\n    t12 += v * b5;\n    t13 += v * b6;\n    t14 += v * b7;\n    t15 += v * b8;\n    t16 += v * b9;\n    t17 += v * b10;\n    t18 += v * b11;\n    t19 += v * b12;\n    t20 += v * b13;\n    t21 += v * b14;\n    t22 += v * b15;\n    v = a[8];\n    t8 += v * b0;\n    t9 += v * b1;\n    t10 += v * b2;\n    t11 += v * b3;\n    t12 += v * b4;\n    t13 += v * b5;\n    t14 += v * b6;\n    t15 += v * b7;\n    t16 += v * b8;\n    t17 += v * b9;\n    t18 += v * b10;\n    t19 += v * b11;\n    t20 += v * b12;\n    t21 += v * b13;\n    t22 += v * b14;\n    t23 += v * b15;\n    v = a[9];\n    t9 += v * b0;\n    t10 += v * b1;\n    t11 += v * b2;\n    t12 += v * b3;\n    t13 += v * b4;\n    t14 += v * b5;\n    t15 += v * b6;\n    t16 += v * b7;\n    t17 += v * b8;\n    t18 += v * b9;\n    t19 += v * b10;\n    t20 += v * b11;\n    t21 += v * b12;\n    t22 += v * b13;\n    t23 += v * b14;\n    t24 += v * b15;\n    v = a[10];\n    t10 += v * b0;\n    t11 += v * b1;\n    t12 += v * b2;\n    t13 += v * b3;\n    t14 += v * b4;\n    t15 += v * b5;\n    t16 += v * b6;\n    t17 += v * b7;\n    t18 += v * b8;\n    t19 += v * b9;\n    t20 += v * b10;\n    t21 += v * b11;\n    t22 += v * b12;\n    t23 += v * b13;\n    t24 += v * b14;\n    t25 += v * b15;\n    v = a[11];\n    t11 += v * b0;\n    t12 += v * b1;\n    t13 += v * b2;\n    t14 += v * b3;\n    t15 += v * b4;\n    t16 += v * b5;\n    t17 += v * b6;\n    t18 += v * b7;\n    t19 += v * b8;\n    t20 += v * b9;\n    t21 += v * b10;\n    t22 += v * b11;\n    t23 += v * b12;\n    t24 += v * b13;\n    t25 += v * b14;\n    t26 += v * b15;\n    v = a[12];\n    t12 += v * b0;\n    t13 += v * b1;\n    t14 += v * b2;\n    t15 += v * b3;\n    t16 += v * b4;\n    t17 += v * b5;\n    t18 += v * b6;\n    t19 += v * b7;\n    t20 += v * b8;\n    t21 += v * b9;\n    t22 += v * b10;\n    t23 += v * b11;\n    t24 += v * b12;\n    t25 += v * b13;\n    t26 += v * b14;\n    t27 += v * b15;\n    v = a[13];\n    t13 += v * b0;\n    t14 += v * b1;\n    t15 += v * b2;\n    t16 += v * b3;\n    t17 += v * b4;\n    t18 += v * b5;\n    t19 += v * b6;\n    t20 += v * b7;\n    t21 += v * b8;\n    t22 += v * b9;\n    t23 += v * b10;\n    t24 += v * b11;\n    t25 += v * b12;\n    t26 += v * b13;\n    t27 += v * b14;\n    t28 += v * b15;\n    v = a[14];\n    t14 += v * b0;\n    t15 += v * b1;\n    t16 += v * b2;\n    t17 += v * b3;\n    t18 += v * b4;\n    t19 += v * b5;\n    t20 += v * b6;\n    t21 += v * b7;\n    t22 += v * b8;\n    t23 += v * b9;\n    t24 += v * b10;\n    t25 += v * b11;\n    t26 += v * b12;\n    t27 += v * b13;\n    t28 += v * b14;\n    t29 += v * b15;\n    v = a[15];\n    t15 += v * b0;\n    t16 += v * b1;\n    t17 += v * b2;\n    t18 += v * b3;\n    t19 += v * b4;\n    t20 += v * b5;\n    t21 += v * b6;\n    t22 += v * b7;\n    t23 += v * b8;\n    t24 += v * b9;\n    t25 += v * b10;\n    t26 += v * b11;\n    t27 += v * b12;\n    t28 += v * b13;\n    t29 += v * b14;\n    t30 += v * b15;\n    t0 += 38 * t16;\n    t1 += 38 * t17;\n    t2 += 38 * t18;\n    t3 += 38 * t19;\n    t4 += 38 * t20;\n    t5 += 38 * t21;\n    t6 += 38 * t22;\n    t7 += 38 * t23;\n    t8 += 38 * t24;\n    t9 += 38 * t25;\n    t10 += 38 * t26;\n    t11 += 38 * t27;\n    t12 += 38 * t28;\n    t13 += 38 * t29;\n    t14 += 38 * t30;\n    // t15 left as is\n    // first car\n    c = 1;\n    v = t0 + c + 65535;\n    c = Math.floor(v / 65536);\n    t0 = v - c * 65536;\n    v = t1 + c + 65535;\n    c = Math.floor(v / 65536);\n    t1 = v - c * 65536;\n    v = t2 + c + 65535;\n    c = Math.floor(v / 65536);\n    t2 = v - c * 65536;\n    v = t3 + c + 65535;\n    c = Math.floor(v / 65536);\n    t3 = v - c * 65536;\n    v = t4 + c + 65535;\n    c = Math.floor(v / 65536);\n    t4 = v - c * 65536;\n    v = t5 + c + 65535;\n    c = Math.floor(v / 65536);\n    t5 = v - c * 65536;\n    v = t6 + c + 65535;\n    c = Math.floor(v / 65536);\n    t6 = v - c * 65536;\n    v = t7 + c + 65535;\n    c = Math.floor(v / 65536);\n    t7 = v - c * 65536;\n    v = t8 + c + 65535;\n    c = Math.floor(v / 65536);\n    t8 = v - c * 65536;\n    v = t9 + c + 65535;\n    c = Math.floor(v / 65536);\n    t9 = v - c * 65536;\n    v = t10 + c + 65535;\n    c = Math.floor(v / 65536);\n    t10 = v - c * 65536;\n    v = t11 + c + 65535;\n    c = Math.floor(v / 65536);\n    t11 = v - c * 65536;\n    v = t12 + c + 65535;\n    c = Math.floor(v / 65536);\n    t12 = v - c * 65536;\n    v = t13 + c + 65535;\n    c = Math.floor(v / 65536);\n    t13 = v - c * 65536;\n    v = t14 + c + 65535;\n    c = Math.floor(v / 65536);\n    t14 = v - c * 65536;\n    v = t15 + c + 65535;\n    c = Math.floor(v / 65536);\n    t15 = v - c * 65536;\n    t0 += c - 1 + 37 * (c - 1);\n    // second car\n    c = 1;\n    v = t0 + c + 65535;\n    c = Math.floor(v / 65536);\n    t0 = v - c * 65536;\n    v = t1 + c + 65535;\n    c = Math.floor(v / 65536);\n    t1 = v - c * 65536;\n    v = t2 + c + 65535;\n    c = Math.floor(v / 65536);\n    t2 = v - c * 65536;\n    v = t3 + c + 65535;\n    c = Math.floor(v / 65536);\n    t3 = v - c * 65536;\n    v = t4 + c + 65535;\n    c = Math.floor(v / 65536);\n    t4 = v - c * 65536;\n    v = t5 + c + 65535;\n    c = Math.floor(v / 65536);\n    t5 = v - c * 65536;\n    v = t6 + c + 65535;\n    c = Math.floor(v / 65536);\n    t6 = v - c * 65536;\n    v = t7 + c + 65535;\n    c = Math.floor(v / 65536);\n    t7 = v - c * 65536;\n    v = t8 + c + 65535;\n    c = Math.floor(v / 65536);\n    t8 = v - c * 65536;\n    v = t9 + c + 65535;\n    c = Math.floor(v / 65536);\n    t9 = v - c * 65536;\n    v = t10 + c + 65535;\n    c = Math.floor(v / 65536);\n    t10 = v - c * 65536;\n    v = t11 + c + 65535;\n    c = Math.floor(v / 65536);\n    t11 = v - c * 65536;\n    v = t12 + c + 65535;\n    c = Math.floor(v / 65536);\n    t12 = v - c * 65536;\n    v = t13 + c + 65535;\n    c = Math.floor(v / 65536);\n    t13 = v - c * 65536;\n    v = t14 + c + 65535;\n    c = Math.floor(v / 65536);\n    t14 = v - c * 65536;\n    v = t15 + c + 65535;\n    c = Math.floor(v / 65536);\n    t15 = v - c * 65536;\n    t0 += c - 1 + 37 * (c - 1);\n    o[0] = t0;\n    o[1] = t1;\n    o[2] = t2;\n    o[3] = t3;\n    o[4] = t4;\n    o[5] = t5;\n    o[6] = t6;\n    o[7] = t7;\n    o[8] = t8;\n    o[9] = t9;\n    o[10] = t10;\n    o[11] = t11;\n    o[12] = t12;\n    o[13] = t13;\n    o[14] = t14;\n    o[15] = t15;\n}\nfunction square(o, a) {\n    mul(o, a, a);\n}\nfunction inv25519(o, inp) {\n    const c = gf();\n    for (let i = 0; i < 16; i++) {\n        c[i] = inp[i];\n    }\n    for (let i = 253; i >= 0; i--) {\n        square(c, c);\n        if (i !== 2 && i !== 4) {\n            mul(c, c, inp);\n        }\n    }\n    for (let i = 0; i < 16; i++) {\n        o[i] = c[i];\n    }\n}\nfunction scalarMult(n, p) {\n    const z = new Uint8Array(32);\n    const x = new Float64Array(80);\n    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();\n    for (let i = 0; i < 31; i++) {\n        z[i] = n[i];\n    }\n    z[31] = (n[31] & 127) | 64;\n    z[0] &= 248;\n    unpack25519(x, p);\n    for (let i = 0; i < 16; i++) {\n        b[i] = x[i];\n    }\n    a[0] = d[0] = 1;\n    for (let i = 254; i >= 0; --i) {\n        const r = (z[i >>> 3] >>> (i & 7)) & 1;\n        sel25519(a, b, r);\n        sel25519(c, d, r);\n        add(e, a, c);\n        sub(a, a, c);\n        add(c, b, d);\n        sub(b, b, d);\n        square(d, e);\n        square(f, a);\n        mul(a, c, a);\n        mul(c, b, e);\n        add(e, a, c);\n        sub(a, a, c);\n        square(b, a);\n        sub(c, d, f);\n        mul(a, c, _121665);\n        add(a, a, d);\n        mul(c, c, a);\n        mul(a, d, f);\n        mul(d, b, x);\n        square(b, e);\n        sel25519(a, b, r);\n        sel25519(c, d, r);\n    }\n    for (let i = 0; i < 16; i++) {\n        x[i + 16] = a[i];\n        x[i + 32] = c[i];\n        x[i + 48] = b[i];\n        x[i + 64] = d[i];\n    }\n    const x32 = x.subarray(32);\n    const x16 = x.subarray(16);\n    inv25519(x32, x32);\n    mul(x16, x16, x32);\n    const q = new Uint8Array(32);\n    pack25519(q, x16);\n    return q;\n}\nexports.scalarMult = scalarMult;\nfunction scalarMultBase(n) {\n    return scalarMult(n, _9);\n}\nexports.scalarMultBase = scalarMultBase;\nfunction generateKeyPairFromSeed(seed) {\n    if (seed.length !== exports.SECRET_KEY_LENGTH) {\n        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);\n    }\n    const secretKey = new Uint8Array(seed);\n    const publicKey = scalarMultBase(secretKey);\n    return {\n        publicKey,\n        secretKey\n    };\n}\nexports.generateKeyPairFromSeed = generateKeyPairFromSeed;\nfunction generateKeyPair(prng) {\n    const seed = (0, random_1.randomBytes)(32, prng);\n    const result = generateKeyPairFromSeed(seed);\n    (0, wipe_1.wipe)(seed);\n    return result;\n}\nexports.generateKeyPair = generateKeyPair;\n/**\n * Returns a shared key between our secret key and a peer's public key.\n *\n * Throws an error if the given keys are of wrong length.\n *\n * If rejectZero is true throws if the calculated shared key is all-zero.\n * From RFC 7748:\n *\n * > Protocol designers using Diffie-Hellman over the curves defined in\n * > this document must not assume \"contributory behavior\".  Specially,\n * > contributory behavior means that both parties' private keys\n * > contribute to the resulting shared key.  Since curve25519 and\n * > curve448 have cofactors of 8 and 4 (respectively), an input point of\n * > small order will eliminate any contribution from the other party's\n * > private key.  This situation can be detected by checking for the all-\n * > zero output, which implementations MAY do, as specified in Section 6.\n * > However, a large number of existing implementations do not do this.\n *\n * IMPORTANT: the returned key is a raw result of scalar multiplication.\n * To use it as a key material, hash it with a cryptographic hash function.\n */\nfunction sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {\n    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {\n        throw new Error(\"X25519: incorrect secret key length\");\n    }\n    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {\n        throw new Error(\"X25519: incorrect public key length\");\n    }\n    const result = scalarMult(mySecretKey, theirPublicKey);\n    if (rejectZero) {\n        let zeros = 0;\n        for (let i = 0; i < result.length; i++) {\n            zeros |= result[i];\n        }\n        if (zeros === 0) {\n            throw new Error(\"X25519: invalid shared key\");\n        }\n    }\n    return result;\n}\nexports.sharedKey = sharedKey;\n//# sourceMappingURL=x25519.js.map\n\n//# sourceURL=webpack://crypt4gh_js/./node_modules/@stablelib/x25519/lib/x25519.js?");

/***/ }),

/***/ "./node_modules/scrypt-js/scrypt.js":
/*!******************************************!*\
  !*** ./node_modules/scrypt-js/scrypt.js ***!
  \******************************************/
/***/ (function(module) {

"use strict";
eval("\n\n(function(root) {\n    const MAX_VALUE = 0x7fffffff;\n\n    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:\n    // See: https://github.com/dchest/scrypt-async-js\n    function SHA256(m) {\n        const K = new Uint32Array([\n           0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n           0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n           0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n           0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n           0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n           0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n           0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n           0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n           0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n           0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n           0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n       ]);\n\n        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;\n        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;\n        const w = new Uint32Array(64);\n\n        function blocks(p) {\n            let off = 0, len = p.length;\n            while (len >= 64) {\n                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;\n\n                for (i = 0; i < 16; i++) {\n                    j = off + i*4;\n                    w[i] = ((p[j] & 0xff)<<24) | ((p[j+1] & 0xff)<<16) |\n                    ((p[j+2] & 0xff)<<8) | (p[j+3] & 0xff);\n                }\n\n                for (i = 16; i < 64; i++) {\n                    u = w[i-2];\n                    t1 = ((u>>>17) | (u<<(32-17))) ^ ((u>>>19) | (u<<(32-19))) ^ (u>>>10);\n\n                    u = w[i-15];\n                    t2 = ((u>>>7) | (u<<(32-7))) ^ ((u>>>18) | (u<<(32-18))) ^ (u>>>3);\n\n                    w[i] = (((t1 + w[i-7]) | 0) + ((t2 + w[i-16]) | 0)) | 0;\n                }\n\n                for (i = 0; i < 64; i++) {\n                    t1 = ((((((e>>>6) | (e<<(32-6))) ^ ((e>>>11) | (e<<(32-11))) ^\n                             ((e>>>25) | (e<<(32-25)))) + ((e & f) ^ (~e & g))) | 0) +\n                          ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;\n\n                    t2 = ((((a>>>2) | (a<<(32-2))) ^ ((a>>>13) | (a<<(32-13))) ^\n                           ((a>>>22) | (a<<(32-22)))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;\n\n                    h = g;\n                    g = f;\n                    f = e;\n                    e = (d + t1) | 0;\n                    d = c;\n                    c = b;\n                    b = a;\n                    a = (t1 + t2) | 0;\n                }\n\n                h0 = (h0 + a) | 0;\n                h1 = (h1 + b) | 0;\n                h2 = (h2 + c) | 0;\n                h3 = (h3 + d) | 0;\n                h4 = (h4 + e) | 0;\n                h5 = (h5 + f) | 0;\n                h6 = (h6 + g) | 0;\n                h7 = (h7 + h) | 0;\n\n                off += 64;\n                len -= 64;\n            }\n        }\n\n        blocks(m);\n\n        let i, bytesLeft = m.length % 64,\n        bitLenHi = (m.length / 0x20000000) | 0,\n        bitLenLo = m.length << 3,\n        numZeros = (bytesLeft < 56) ? 56 : 120,\n        p = m.slice(m.length - bytesLeft, m.length);\n\n        p.push(0x80);\n        for (i = bytesLeft + 1; i < numZeros; i++) { p.push(0); }\n        p.push((bitLenHi >>> 24) & 0xff);\n        p.push((bitLenHi >>> 16) & 0xff);\n        p.push((bitLenHi >>> 8)  & 0xff);\n        p.push((bitLenHi >>> 0)  & 0xff);\n        p.push((bitLenLo >>> 24) & 0xff);\n        p.push((bitLenLo >>> 16) & 0xff);\n        p.push((bitLenLo >>> 8)  & 0xff);\n        p.push((bitLenLo >>> 0)  & 0xff);\n\n        blocks(p);\n\n        return [\n            (h0 >>> 24) & 0xff, (h0 >>> 16) & 0xff, (h0 >>> 8) & 0xff, (h0 >>> 0) & 0xff,\n            (h1 >>> 24) & 0xff, (h1 >>> 16) & 0xff, (h1 >>> 8) & 0xff, (h1 >>> 0) & 0xff,\n            (h2 >>> 24) & 0xff, (h2 >>> 16) & 0xff, (h2 >>> 8) & 0xff, (h2 >>> 0) & 0xff,\n            (h3 >>> 24) & 0xff, (h3 >>> 16) & 0xff, (h3 >>> 8) & 0xff, (h3 >>> 0) & 0xff,\n            (h4 >>> 24) & 0xff, (h4 >>> 16) & 0xff, (h4 >>> 8) & 0xff, (h4 >>> 0) & 0xff,\n            (h5 >>> 24) & 0xff, (h5 >>> 16) & 0xff, (h5 >>> 8) & 0xff, (h5 >>> 0) & 0xff,\n            (h6 >>> 24) & 0xff, (h6 >>> 16) & 0xff, (h6 >>> 8) & 0xff, (h6 >>> 0) & 0xff,\n            (h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, (h7 >>> 0) & 0xff\n        ];\n    }\n\n    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {\n        // compress password if it's longer than hash block length\n        password = (password.length <= 64) ? password : SHA256(password);\n\n        const innerLen = 64 + salt.length + 4;\n        const inner = new Array(innerLen);\n        const outerKey = new Array(64);\n\n        let i;\n        let dk = [];\n\n        // inner = (password ^ ipad) || salt || counter\n        for (i = 0; i < 64; i++) { inner[i] = 0x36; }\n        for (i = 0; i < password.length; i++) { inner[i] ^= password[i]; }\n        for (i = 0; i < salt.length; i++) { inner[64 + i] = salt[i]; }\n        for (i = innerLen - 4; i < innerLen; i++) { inner[i] = 0; }\n\n        // outerKey = password ^ opad\n        for (i = 0; i < 64; i++) outerKey[i] = 0x5c;\n        for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];\n\n        // increments counter inside inner\n        function incrementCounter() {\n            for (let i = innerLen - 1; i >= innerLen - 4; i--) {\n                inner[i]++;\n                if (inner[i] <= 0xff) return;\n                inner[i] = 0;\n            }\n        }\n\n        // output blocks = SHA256(outerKey || SHA256(inner)) ...\n        while (dkLen >= 32) {\n            incrementCounter();\n            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));\n            dkLen -= 32;\n        }\n        if (dkLen > 0) {\n            incrementCounter();\n            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));\n        }\n\n        return dk;\n    }\n\n    // The following is an adaptation of scryptsy\n    // See: https://www.npmjs.com/package/scryptsy\n    function blockmix_salsa8(BY, Yi, r, x, _X) {\n        let i;\n\n        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);\n        for (i = 0; i < 2 * r; i++) {\n            blockxor(BY, i * 16, _X, 16);\n            salsa20_8(_X, x);\n            arraycopy(_X, 0, BY, Yi + (i * 16), 16);\n        }\n\n        for (i = 0; i < r; i++) {\n            arraycopy(BY, Yi + (i * 2) * 16, BY, (i * 16), 16);\n        }\n\n        for (i = 0; i < r; i++) {\n            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);\n        }\n    }\n\n    function R(a, b) {\n        return (a << b) | (a >>> (32 - b));\n    }\n\n    function salsa20_8(B, x) {\n        arraycopy(B, 0, x, 0, 16);\n\n        for (let i = 8; i > 0; i -= 2) {\n            x[ 4] ^= R(x[ 0] + x[12], 7);\n            x[ 8] ^= R(x[ 4] + x[ 0], 9);\n            x[12] ^= R(x[ 8] + x[ 4], 13);\n            x[ 0] ^= R(x[12] + x[ 8], 18);\n            x[ 9] ^= R(x[ 5] + x[ 1], 7);\n            x[13] ^= R(x[ 9] + x[ 5], 9);\n            x[ 1] ^= R(x[13] + x[ 9], 13);\n            x[ 5] ^= R(x[ 1] + x[13], 18);\n            x[14] ^= R(x[10] + x[ 6], 7);\n            x[ 2] ^= R(x[14] + x[10], 9);\n            x[ 6] ^= R(x[ 2] + x[14], 13);\n            x[10] ^= R(x[ 6] + x[ 2], 18);\n            x[ 3] ^= R(x[15] + x[11], 7);\n            x[ 7] ^= R(x[ 3] + x[15], 9);\n            x[11] ^= R(x[ 7] + x[ 3], 13);\n            x[15] ^= R(x[11] + x[ 7], 18);\n            x[ 1] ^= R(x[ 0] + x[ 3], 7);\n            x[ 2] ^= R(x[ 1] + x[ 0], 9);\n            x[ 3] ^= R(x[ 2] + x[ 1], 13);\n            x[ 0] ^= R(x[ 3] + x[ 2], 18);\n            x[ 6] ^= R(x[ 5] + x[ 4], 7);\n            x[ 7] ^= R(x[ 6] + x[ 5], 9);\n            x[ 4] ^= R(x[ 7] + x[ 6], 13);\n            x[ 5] ^= R(x[ 4] + x[ 7], 18);\n            x[11] ^= R(x[10] + x[ 9], 7);\n            x[ 8] ^= R(x[11] + x[10], 9);\n            x[ 9] ^= R(x[ 8] + x[11], 13);\n            x[10] ^= R(x[ 9] + x[ 8], 18);\n            x[12] ^= R(x[15] + x[14], 7);\n            x[13] ^= R(x[12] + x[15], 9);\n            x[14] ^= R(x[13] + x[12], 13);\n            x[15] ^= R(x[14] + x[13], 18);\n        }\n\n        for (let i = 0; i < 16; ++i) {\n            B[i] += x[i];\n        }\n    }\n\n    // naive approach... going back to loop unrolling may yield additional performance\n    function blockxor(S, Si, D, len) {\n        for (let i = 0; i < len; i++) {\n            D[i] ^= S[Si + i]\n        }\n    }\n\n    function arraycopy(src, srcPos, dest, destPos, length) {\n        while (length--) {\n            dest[destPos++] = src[srcPos++];\n        }\n    }\n\n    function checkBufferish(o) {\n        if (!o || typeof(o.length) !== 'number') { return false; }\n\n        for (let i = 0; i < o.length; i++) {\n            const v = o[i];\n            if (typeof(v) !== 'number' || v % 1 || v < 0 || v >= 256) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function ensureInteger(value, name) {\n        if (typeof(value) !== \"number\" || (value % 1)) { throw new Error('invalid ' + name); }\n        return value;\n    }\n\n    // N = Cpu cost, r = Memory cost, p = parallelization cost\n    // callback(error, progress, key)\n    function _scrypt(password, salt, N, r, p, dkLen, callback) {\n\n        N = ensureInteger(N, 'N');\n        r = ensureInteger(r, 'r');\n        p = ensureInteger(p, 'p');\n\n        dkLen = ensureInteger(dkLen, 'dkLen');\n\n        if (N === 0 || (N & (N - 1)) !== 0) { throw new Error('N must be power of 2'); }\n\n        if (N > MAX_VALUE / 128 / r) { throw new Error('N too large'); }\n        if (r > MAX_VALUE / 128 / p) { throw new Error('r too large'); }\n\n        if (!checkBufferish(password)) {\n            throw new Error('password must be an array or buffer');\n        }\n        password = Array.prototype.slice.call(password);\n\n        if (!checkBufferish(salt)) {\n            throw new Error('salt must be an array or buffer');\n        }\n        salt = Array.prototype.slice.call(salt);\n\n        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);\n        const B = new Uint32Array(p * 32 * r)\n        for (let i = 0; i < B.length; i++) {\n            const j = i * 4;\n            B[i] = ((b[j + 3] & 0xff) << 24) |\n                   ((b[j + 2] & 0xff) << 16) |\n                   ((b[j + 1] & 0xff) << 8) |\n                   ((b[j + 0] & 0xff) << 0);\n        }\n\n        const XY = new Uint32Array(64 * r);\n        const V = new Uint32Array(32 * r * N);\n\n        const Yi = 32 * r;\n\n        // scratch space\n        const x = new Uint32Array(16);       // salsa20_8\n        const _X = new Uint32Array(16);      // blockmix_salsa8\n\n        const totalOps = p * N * 2;\n        let currentOp = 0;\n        let lastPercent10 = null;\n\n        // Set this to true to abandon the scrypt on the next step\n        let stop = false;\n\n        // State information\n        let state = 0;\n        let i0 = 0, i1;\n        let Bi;\n\n        // How many blockmix_salsa8 can we do per step?\n        const limit = callback ? parseInt(1000 / r): 0xffffffff;\n\n        // Trick from scrypt-async; if there is a setImmediate shim in place, use it\n        const nextTick = (typeof(setImmediate) !== 'undefined') ? setImmediate : setTimeout;\n\n        // This is really all I changed; making scryptsy a state machine so we occasionally\n        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo\n        const incrementalSMix = function() {\n            if (stop) {\n                return callback(new Error('cancelled'), currentOp / totalOps);\n            }\n\n            let steps;\n\n            switch (state) {\n                case 0:\n                    // for (var i = 0; i < p; i++)...\n                    Bi = i0 * 32 * r;\n\n                    arraycopy(B, Bi, XY, 0, Yi);                       // ROMix - 1\n\n                    state = 1;                                         // Move to ROMix 2\n                    i1 = 0;\n\n                    // Fall through\n\n                case 1:\n\n                    // Run up to 1000 steps of the first inner smix loop\n                    steps = N - i1;\n                    if (steps > limit) { steps = limit; }\n                    for (let i = 0; i < steps; i++) {                  // ROMix - 2\n                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi)         // ROMix - 3\n                        blockmix_salsa8(XY, Yi, r, x, _X);             // ROMix - 4\n                    }\n\n                    // for (var i = 0; i < N; i++)\n                    i1 += steps;\n                    currentOp += steps;\n\n                    if (callback) {\n                        // Call the callback with the progress (optionally stopping us)\n                        const percent10 = parseInt(1000 * currentOp / totalOps);\n                        if (percent10 !== lastPercent10) {\n                            stop = callback(null, currentOp / totalOps);\n                            if (stop) { break; }\n                            lastPercent10 = percent10;\n                        }\n                    }\n\n                    if (i1 < N) { break; }\n\n                    i1 = 0;                                          // Move to ROMix 6\n                    state = 2;\n\n                    // Fall through\n\n                case 2:\n\n                    // Run up to 1000 steps of the second inner smix loop\n                    steps = N - i1;\n                    if (steps > limit) { steps = limit; }\n                    for (let i = 0; i < steps; i++) {                // ROMix - 6\n                        const offset = (2 * r - 1) * 16;             // ROMix - 7\n                        const j = XY[offset] & (N - 1);\n                        blockxor(V, j * Yi, XY, Yi);                 // ROMix - 8 (inner)\n                        blockmix_salsa8(XY, Yi, r, x, _X);           // ROMix - 9 (outer)\n                    }\n\n                    // for (var i = 0; i < N; i++)...\n                    i1 += steps;\n                    currentOp += steps;\n\n                    // Call the callback with the progress (optionally stopping us)\n                    if (callback) {\n                        const percent10 = parseInt(1000 * currentOp / totalOps);\n                        if (percent10 !== lastPercent10) {\n                            stop = callback(null, currentOp / totalOps);\n                            if (stop) { break; }\n                            lastPercent10 = percent10;\n                        }\n                    }\n\n                    if (i1 < N) { break; }\n\n                    arraycopy(XY, 0, B, Bi, Yi);                     // ROMix - 10\n\n                    // for (var i = 0; i < p; i++)...\n                    i0++;\n                    if (i0 < p) {\n                        state = 0;\n                        break;\n                    }\n\n                    b = [];\n                    for (let i = 0; i < B.length; i++) {\n                        b.push((B[i] >>  0) & 0xff);\n                        b.push((B[i] >>  8) & 0xff);\n                        b.push((B[i] >> 16) & 0xff);\n                        b.push((B[i] >> 24) & 0xff);\n                    }\n\n                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);\n\n                    // Send the result to the callback\n                    if (callback) { callback(null, 1.0, derivedKey); }\n\n                    // Done; don't break (which would reschedule)\n                    return derivedKey;\n            }\n\n            // Schedule the next steps\n            if (callback) { nextTick(incrementalSMix); }\n        }\n\n        // Run the smix state machine until completion\n        if (!callback) {\n            while (true) {\n                const derivedKey = incrementalSMix();\n                if (derivedKey != undefined) { return derivedKey; }\n            }\n        }\n\n        // Bootstrap the async incremental smix\n        incrementalSMix();\n    }\n\n    const lib = {\n        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {\n            return new Promise(function(resolve, reject) {\n                let lastProgress = 0;\n                if (progressCallback) { progressCallback(0); }\n                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {\n                    if (error) {\n                        reject(error);\n                    } else if (key) {\n                        if (progressCallback && lastProgress !== 1) {\n                            progressCallback(1);\n                        }\n                        resolve(new Uint8Array(key));\n                    } else if (progressCallback && progress !== lastProgress) {\n                        lastProgress = progress;\n                        return progressCallback(progress);\n                    }\n                });\n            });\n        },\n        syncScrypt: function(password, salt, N, r, p, dkLen) {\n            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));\n        }\n    };\n\n    // node.js\n    if (true) {\n       module.exports = lib;\n\n    // RequireJS/AMD\n    // http://www.requirejs.org/docs/api.html\n    // https://github.com/amdjs/amdjs-api/wiki/AMD\n    } else {}\n\n})(this);\n\n\n//# sourceURL=webpack://crypt4gh_js/./node_modules/scrypt-js/scrypt.js?");

/***/ }),

/***/ "./src/check_fileformat.js":
/*!*********************************!*\
  !*** ./src/check_fileformat.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const dec = __webpack_require__(/*! ./decryption */ \"./src/decryption.js\")\n\n/**\n * Function to check whether an already encrypted file is in crypt4gh format or not\n * and whether the person uploading the file, has access to the unencrypted data\n * @param {*} input => data to check for crypt4gh format\n * @param {*} seckey => key to decrypt input\n * @returns => false, if data can't be decrypted. true, if it can be decrypted.\n */\nexports.check = async function (input, seckey) {\n  try {\n    const header = await input.subarray(0, 1000)\n    const headerPackets = dec.parse(header)\n    const decryptedPackets = dec.decrypt_header(headerPackets[0], seckey)\n    if (decryptedPackets[0].length === 0) {\n      return false\n    } else {\n      return true\n    }\n  } catch (e) {\n    console.trace(\"File checking wasn't possible!\")\n  }\n}\n\n\n//# sourceURL=webpack://crypt4gh_js/./src/check_fileformat.js?");

/***/ }),

/***/ "./src/check_keyfiles.js":
/*!*******************************!*\
  !*** ./src/check_keyfiles.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const helperfunction = __webpack_require__(/*! ./helper functions */ \"./src/helper functions.js\")\nconst crypto = __webpack_require__(/*! crypto */ \"?fe02\")\nconst scrypt = __webpack_require__(/*! scrypt-js */ \"./node_modules/scrypt-js/scrypt.js\")\n\nconst magicBytestring = helperfunction.string2byte('c4gh-v1')\nconst kdfNoneBytestring = helperfunction.string2byte('none')\nconst kdfScript = helperfunction.string2byte('scrypt')\nconst chiperNoneBytestring = helperfunction.string2byte('none')\nconst chiperChacha = helperfunction.string2byte('chacha20_poly1305')\nconst seckeyStart = '-----BEGIN CRYPT4GH PRIVATE KEY-----'\nconst seckeyEnd = '-----END CRYPT4GH PRIVATE KEY-----'\nconst pubkeyStart = '-----BEGIN CRYPT4GH PUBLIC KEY-----'\nconst pubkeyEnd = '-----END CRYPT4GH PUBLIC KEY-----'\n\n/**\n * Function to check if given seckey and/or pubkeyfiles are in crypt4gh format.\n * Additionally decrypts the key, if the seckey/pubkey file is password protected\n * @param {*} keys => List containing keys in Uint8Array format\n * @param {*} password => optional parameter, to decrypt password protected\n *                         secret keys\n * @returns => list of 32byte keys, starting with the seckret key, pubkeys second\n */\nexports.encryption_keyfiles = async (keys, password = '') => {\n  const solvedKeys = []\n  try {\n    for (let i = 0; i < keys.length; i++) {\n      let seckey = new Uint8Array(32)\n      let pubkey = new Uint8Array(32)\n      const wordWrap1 = keys[i].indexOf('\\n')\n      const wordWrap2 = keys[i].indexOf('\\n', wordWrap1 + 1)\n      const wordWrap3 = keys[i].indexOf('\\n', wordWrap2 + 1)\n      const row1 = keys[i].substring(0, wordWrap1)\n      const row2 = keys[i].substring(wordWrap1 + 1, wordWrap2)\n      const row3 = keys[i].substring(wordWrap2 + 1, wordWrap3)\n      const row2Array = helperfunction.base64ToArrayBuffer(row2)\n      if (row1 === seckeyStart && row3 === seckeyEnd) {\n        seckey = await secret(row2Array, seckey, password)\n        solvedKeys.push(seckey)\n      } else if (row1 === pubkeyStart && row3 === pubkeyEnd) {\n        const keyPub = keys[i].substring(36, 80)\n        pubkey = helperfunction.base64ToArrayBuffer(keyPub)\n        solvedKeys.push(pubkey)\n      } else {\n        console.trace('Not a crypt4gh keyfile!')\n      }\n    }\n    return solvedKeys\n  } catch (e) {\n    console.trace(\"Keyfiles couldn't be decrypted!\")\n  }\n}\n\n/**\n * Function to decrypt the secret key\n * @param {*} keyContent => encrypted key content\n * @param {*} seckey => Uint8array for seckey\n * @returns => secret key (Uint8array 32 bytes)\n */\nasync function secret (keyContent, seckey, password) {\n  try {\n    if (helperfunction.equal(keyContent.subarray(0, 7), magicBytestring)) {\n      if (helperfunction.equal(keyContent.subarray(9, 13), kdfNoneBytestring)) {\n        if (helperfunction.equal(keyContent.subarray(15, 19), chiperNoneBytestring)) {\n          seckey = keyContent.subarray(21)\n          return seckey\n        }\n      } else if (helperfunction.equal(keyContent.subarray(9, 15), kdfScript)) {\n        const kdfoptions = keyContent.subarray(17, 37)\n        const salt = kdfoptions.subarray(4)\n        if (helperfunction.equal(keyContent.subarray(39, 56), chiperChacha)) {\n          const N = 16384; const r = 8; const p = 1\n          const dklen = 32\n          const keyPrmoise = scrypt.scrypt(helperfunction.string2byte(password), salt, N, r, p, dklen)\n          const key = keyPrmoise.then(function (result) {\n            const sharedkey = result\n            const nonce = keyContent.subarray(58, 70)\n            const encData = keyContent.subarray(70)\n            const algorithm = 'chacha20-poly1305'\n            const cipher = crypto.createCipheriv(algorithm, sharedkey, nonce)\n            const encryptedResult = cipher.update(encData)\n            const x = new Uint8Array(encryptedResult.subarray(0, 32))\n            return x\n          })\n          return await key\n        }\n      } else {\n        console.trace('Wrong encryption method')\n      }\n    }\n  } catch (e) {\n    console.trace('Secret key data could not be decrypted!')\n  }\n}\n\n\n//# sourceURL=webpack://crypt4gh_js/./src/check_keyfiles.js?");

/***/ }),

/***/ "./src/decryption.js":
/*!***************************!*\
  !*** ./src/decryption.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const helperfunction = __webpack_require__(/*! ./helper functions */ \"./src/helper functions.js\")\nconst x25519 = __webpack_require__(/*! @stablelib/x25519 */ \"./node_modules/@stablelib/x25519/lib/x25519.js\")\nconst Blake2b = __webpack_require__(/*! @stablelib/blake2b */ \"./node_modules/@stablelib/blake2b/lib/blake2b.js\")\nconst dec = __webpack_require__(/*! ./decryption */ \"./src/decryption.js\")\nconst crypto = __webpack_require__(/*! crypto */ \"?fe02\")\n\nexports.SEGMENT_SIZE = 65536\nconst PacketTypeDataEnc = '0000'\nconst PacketTypeEditList = '1000'\nconst encryptionMethod = '0000' // only (xchacha20poly1305)\nconst magicBytestring = helperfunction.string2byte('crypt4gh')\n\nexports.pureDecryption = async function (d, key) {\n  const nonce = await d.subarray(0, 12)\n  const enc = await d.subarray(12)\n  const algorithm = 'chacha20-poly1305'\n  const decipher = crypto.createDecipheriv(algorithm, Buffer.from(key, 'hex'), nonce)\n  const decrypted = decipher.update(enc)\n  const plaintext = new Uint8Array(decrypted.slice(0, -16))\n  return await Promise.resolve(plaintext)\n}\n\nexports.pureEdit = function (d) {\n  const edits = calculateEditlist(d)\n  return edits\n}\n/**\n * Function checks if a decryption is possible, by checking if the given seckey is able to decode a header packet.\n * @param {*} header => header part of the encrypted data\n * @param {*} seckeys => secret key to decrypt header packet\n * @returns => List containing the sessionkey, nonce, body, editlist and position bodystart\n */\nexports.header_deconstruction = function (header, seckeys) {\n  try {\n    const headerPackets = dec.parse(header)\n    const decryptedPackets = dec.decrypt_header(headerPackets[0], seckeys)\n    const partitionedPackages = partitionPackets(decryptedPackets[0])\n    const sessionKey = parseEncPacket(partitionedPackages[0][0])\n    return [sessionKey, decryptedPackets[2], headerPackets[1], partitionedPackages[1], headerPackets[2]]\n  } catch (e) {\n    console.trace('header deconstruction not possible.')\n  }\n}\n\n/**\n * Function to check if the input data is in Crypt4gh format, version number and #packages\n * @param {*} header => start of the file containing the header packages\n * @returns => List containing the list of header packages, body and position bodystart\n */\nexports.parse = function (header) {\n  try {\n    // checken magic number\n    const magicHeaderDecryption = new TextDecoder().decode(header.subarray(0, 8))\n    const magicHeaderOrignal = new TextDecoder().decode(magicBytestring)\n    if (magicHeaderDecryption !== magicHeaderOrignal) console.trace('Not a crypt4gh file')\n    // check version number\n    const version = new Uint8Array(header.subarray(8, 12))\n    if (version[0] !== 1) console.trace('Only version 1 is accepted')\n    // check packet count\n    const numPakets = new Uint32Array(new Uint8Array(header.subarray(12, 16)))\n    if (numPakets[0] === 0) console.trace('No packages!')\n    // extract packets -- returns list of packets\n    const extracted = dec.extract_packets(numPakets[0], header)\n    return [extracted[0], extracted[1], extracted[2]]\n  } catch (e) {\n    console.trace('header parsing not possible.')\n  }\n}\n\n/**\n * Function to extract the individual header packages from the header\n * @param {*} packetNum => #header packages\n * @param {*} header => start of the file containing the header packages\n * @returns  => List containing the list of header packages, body and position bodystart\n */\nexports.extract_packets = function (packetNum, header) {\n  const listHeaderPackages = []\n  let position = 0\n  try {\n    for (let i = 0; i < packetNum; i++) {\n      const currentPackage = []\n      const headerStart = 16\n      if (i === 0) {\n        const firstUint32 = new Uint32Array(new Uint8Array(header.slice(16, 20).buffer))\n        position = headerStart // first_header_packet_length + header_start;\n        for (let j = 0; j < firstUint32[0]; j++) {\n          currentPackage.push(header[position + j])\n        }\n        position = position + firstUint32[0]\n      } else {\n        const uint32 = new Uint32Array(new Uint8Array(header.slice(position, position + 4)))\n        for (let j = 0; j < uint32[0]; j++) {\n          currentPackage.push(header[position + j])\n        }\n        position = position + uint32[0]\n      }\n      listHeaderPackages.push(currentPackage)\n    }\n    const bodyBuffer = header.slice(position)\n    return [listHeaderPackages, bodyBuffer, position]\n  } catch (e) {\n    console.trace(\"packages couln't be extracted.\")\n  }\n}\n\n/**\n * Function to decrypt the seckey fitting header package\n * @param {*} headerPackets => list of header packages\n * @param {*} seckeys => seckey to decode a header package\n * @returns => List containing the decrypted package, the undecrypted packages and the nonce\n */\nexports.decrypt_header = function (headerPackets, seckeys) {\n  try {\n    seckeys = [seckeys]\n    const decryptedPackets = []\n    const undecryptablePackets = []\n    let nonceUint8\n    for (let i = 0; i < headerPackets.length; i++) {\n      const wKeyUint8 = new Uint8Array(headerPackets[i].slice(8, 40))\n      nonceUint8 = new Uint8Array(headerPackets[i].slice(40, 52))\n      const encryptedUint8 = new Uint8Array(headerPackets[i].slice(52))\n      for (let j = 0; j < seckeys.length; j++) {\n        const k = x25519.generateKeyPairFromSeed(seckeys[j])\n        const dh = x25519.sharedKey(seckeys[j], wKeyUint8)\n        const uint8Blake2b = new Uint8Array(dh.length + wKeyUint8.length + k.publicKey.length)\n        uint8Blake2b.set(dh)\n        uint8Blake2b.set(k.publicKey, dh.length)\n        uint8Blake2b.set(wKeyUint8, dh.length + wKeyUint8.length)\n        const blake2b = new Blake2b.BLAKE2b()\n        blake2b.update(uint8Blake2b)\n        const uint8FromBlake2b = blake2b.digest()\n        const sharedKey = uint8FromBlake2b.subarray(0, 32)\n        const algorithm = 'chacha20-poly1305'\n        const decipher = crypto.createDecipheriv(algorithm, Buffer.from(sharedKey, 'hex'), nonceUint8)\n        const decrypted = decipher.update(encryptedUint8)\n        const plaintext = new Uint8Array(decrypted.slice(0, -16))\n        if (plaintext) {\n          decryptedPackets.push(plaintext)\n        } else {\n          undecryptablePackets.push(headerPackets[i])\n        }\n      }\n    }\n    return [decryptedPackets, undecryptablePackets, nonceUint8]\n  } catch (e) {\n    console.trace('Header could not be decrypted.')\n  }\n}\n\n/**\n * Function to devide the packages in encryption packages and edit packages\n * @param {*} packets => List of packages\n * @returns => Two dimensional Array containing first the encryption packages and second the edit packages\n */\nfunction partitionPackets (packets) {\n  try {\n    const encPackets = []\n    const editPackets = []\n    for (let i = 0; i < packets.length; i++) {\n      const packetType = [packets[i][0], packets[i][1], packets[i][2], packets[i][3]].join('')\n      if (packetType === PacketTypeDataEnc) {\n        encPackets.push(packets[i].subarray(4))\n      } else if (packetType === PacketTypeEditList) {\n        editPackets.push(packets[i].subarray(8))\n      } else console.trace('Invalid package type')\n    }\n    return [encPackets, editPackets]\n  } catch (e) {\n    console.trace('Package partition not possible.')\n  }\n}\n\n/**\n * Function to parse the encryption packages\n * @param {*} packet => encryption package\n * @returns => session key, to decrypt the encrypted data\n */\nfunction parseEncPacket (packet) {\n  try {\n    const encMethod = [packet[0], packet[1], packet[2], packet[3]].join('')\n    let sessionKey\n    if (encMethod !== encryptionMethod) console.trace('Invalid encryption method!')\n    else {\n      sessionKey = packet.slice(4)\n    }\n    return sessionKey\n  } catch (e) {\n    console.trace('encryption package could not be parsed.')\n  }\n}\n\n/**\n * Function to apply the edit list (original algorithm at http://samtools.github.io/hts-specs/crypt4gh.pdf page 15)\n * @param {*} edlist => editlist extracted from the edit package\n * @param {*} decryptedText => already decrypted input data\n * @returns => decrypted data edited according to the editlist\n */\nexports.applyEditlist = function (edlist, decryptedText) {\n  try {\n    const editedData = []\n    let pos = BigInt(0)\n    const len = BigInt(decryptedText.length)\n    for (let i = 0; i < edlist.length; i = i + 2) {\n      const discard = edlist[i]\n      pos = pos + discard\n      if (i === edlist.length - 1) {\n        const part = decryptedText.subarray(Number(pos), Number(len))\n        editedData.push(part)\n      } else {\n        const keep = edlist[i + 1]\n        const part = decryptedText.subarray(Number(pos), Number(pos) + Number(keep))\n        editedData.push(part)\n        pos = pos + keep\n      }\n    }\n    let length = 0\n    editedData.forEach(item => {\n      length += item.length\n    })\n    // Create a new array with total length and merge all source arrays.\n    const mergedArray = new Uint8Array(length)\n    let offset = 0\n    editedData.forEach(item => {\n      mergedArray.set(item, offset)\n      offset += item.length\n    })\n    return mergedArray\n  } catch (e) {\n    console.trace('edit list could not be applied.')\n  }\n}\n\n/**\n * blocks2encrypt is needed to prepare the edit informations to calculate new editlists for each block\n * @param {*} headerInformation 2 dim array containing the header Informations, needed to decrypt the data\n * @returns an Array containing the addeded editlist (summed values of editlist), the editlist and a boolean if the og editlist was even or odd.\n */\nfunction blocks2encrypt (headerInformation) {\n  // 1.Step: Welche Blcke mssen entschlsselt werden\n  const edit64 = new BigInt64Array(headerInformation[3][0].buffer)\n  let editlist = edit64.subarray(1)\n  let addedEdit = []\n  let j = 0n\n  for (let i = 0; i < editlist.length; i++) {\n    j = j + editlist[i]\n    addedEdit.push(j)\n  }\n  // ungerade editlist anpassen\n  let unEven = false\n  const editOdd = new BigInt64Array(editlist.length + 1)\n  if (editlist.length % 2 !== 0) {\n    unEven = true\n    const sum = (editlist.reduce((partialSum, a) => partialSum + a, 0n))\n    editOdd.set(editlist)\n    editOdd[editOdd.length - 1] = 65536n * ((sum / 65536n) + 1n) - sum\n  }\n  // 2.Map erstellen\n  if (editlist.length % 2 !== 0) {\n    addedEdit = []\n    editlist = editOdd\n    let j = 0n\n    for (let i = 0; i < editlist.length; i++) {\n      j = j + editlist[i]\n      addedEdit.push(j)\n    }\n  }\n  return [addedEdit, editlist, unEven]\n}\n\n/**\n * calculateEditlist is a function to calculate edit lists for each block from the original editlist.\n * @param {*} headerInformation 2 dim array containing the header Informations, needed to decrypt the data\n * @param {*} encryptedData encrypted data whitch is about to be decrypted\n * @param {*} chacha20poly1305 decryption method\n * @returns Array containing a map with the edits for each block and a boolean if the og editlist was even or odd.\n */\nfunction calculateEditlist (headerInformation) {\n  const preEdit = blocks2encrypt(headerInformation)\n  let bEven = 0\n  const blocks = new Map()\n  for (let i = 0; i < preEdit[0].length; i++) {\n    if (i % 2 === 0) {\n      bEven = Number(((preEdit[0][i] - 1n) / 65536n) + 1n)\n    } else {\n      const bOdd = Number(((preEdit[0][i] - 1n) / 65536n) + 1n)\n      if (bEven === bOdd && i >= 2) {\n        if (Number(((preEdit[0][i - 2] - 1n) / 65536n) + 1n) === bOdd) {\n          blocks.set(bEven, [...blocks.get(bEven), preEdit[1][i - 1]])\n          blocks.set(bEven, [...blocks.get(bEven), preEdit[1][i]])\n        } else {\n          const lastKey = [...blocks.keys()].pop()\n          const sum = 65536n - ((blocks.get(lastKey).reduce((partialSum, a) => partialSum + a, 0n))) + BigInt((65536 * (bOdd - 2)))\n          blocks.set(bEven, [preEdit[1][i - 1] - sum])\n          blocks.set(bEven, [...blocks.get(bEven), preEdit[1][i]])\n        }\n      } else if (bEven === bOdd && i < 2) {\n        if (blocks.has(bEven)) {\n          if (preEdit[1][i - 1] > 65536n) {\n            blocks.set(bEven, [...blocks.get(bEven), preEdit[1][i - 1] - (BigInt(bEven - 1) * 65536n)])\n          } else {\n            blocks.set(bEven, [...blocks.get(bEven), preEdit[1][i - 1]])\n          }\n        } else {\n          if (preEdit[1][i - 1] > 65536n) {\n            blocks.set(bEven, [preEdit[1][i - 1] - (BigInt(bEven - 1) * 65536n)])\n          } else {\n            blocks.set(bEven, [preEdit[1][i - 1]])\n          }\n        }\n        blocks.set(bEven, [...blocks.get(bEven), preEdit[1][i]])\n      } else if (bEven !== bOdd) {\n        if (blocks.has(bEven)) {\n          if (preEdit[1][i - 1] > 65536n) {\n            blocks.set(bEven, [...blocks.get(bEven), preEdit[1][i - 1] - (BigInt(bEven - 1) * 65536n)])\n          } else {\n            blocks.set(bEven, [...blocks.get(bEven), preEdit[1][i - 1]])\n          }\n        } else {\n          if (preEdit[1][i - 1] > 65536n) {\n            blocks.set(bEven, [preEdit[1][i - 1] - (BigInt(bEven - 1) * 65536n)])\n          } else {\n            blocks.set(bEven, [preEdit[1][i - 1]])\n          }\n        }\n        if (preEdit[1][i - 1] > 65536) {\n          blocks.set(bEven, [...blocks.get(bEven), 65536n * BigInt(bEven) - preEdit[1][i - 1]])\n        } else {\n          blocks.set(bEven, [...blocks.get(bEven), 65536n - preEdit[1][i - 1]])\n        }\n        const lastKey = [...blocks.keys()].pop()\n        const x = (preEdit[1][i] / 65536n)\n        if (preEdit[1][i] > 65536n) {\n          for (let j = lastKey + 1; j < Number(x + 1n); j++) {\n            blocks.set(j, [0n, 65536n])\n          }\n        }\n        blocks.set(bOdd, [0n])\n        if (Number(x) > 0) {\n          if (preEdit[1][i - 1] > 65536) {\n            blocks.set(bOdd, [...blocks.get(bOdd), preEdit[1][i] - (65536n * BigInt(bEven) - preEdit[1][i - 1])])\n          } else {\n            blocks.set(bOdd, [...blocks.get(bOdd), preEdit[1][i] - (65536n * x - preEdit[1][i - 1])])\n          }\n        } else {\n          if (preEdit[1][i - 1] > 65536) {\n            blocks.set(bOdd, [...blocks.get(bOdd), preEdit[1][i] - (65536n * BigInt(bEven) - preEdit[1][i - 1])])\n          } else {\n            blocks.set(bOdd, [...blocks.get(bOdd), preEdit[1][i] - (65536n * (x + 1n) - preEdit[1][i - 1])])\n          }\n        }\n      }\n    }\n  }\n  return [blocks, preEdit[2]]\n}\n\n\n//# sourceURL=webpack://crypt4gh_js/./src/decryption.js?");

/***/ }),

/***/ "./src/encryption.js":
/*!***************************!*\
  !*** ./src/encryption.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const helperfunction = __webpack_require__(/*! ./helper functions */ \"./src/helper functions.js\")\nconst x25519 = __webpack_require__(/*! @stablelib/x25519 */ \"./node_modules/@stablelib/x25519/lib/x25519.js\")\nconst Blake2b = __webpack_require__(/*! @stablelib/blake2b */ \"./node_modules/@stablelib/blake2b/lib/blake2b.js\")\nconst enc = __webpack_require__(/*! ./encryption */ \"./src/encryption.js\")\nconst crypto = __webpack_require__(/*! crypto */ \"?fe02\")\n\nconst PacketTypeDataEnc = new Uint32Array([0])\nconst PacketTypeEditList = new Uint32Array([1])\nconst magicBytestring = helperfunction.string2byte('crypt4gh')\n\nexports.encHeader = function (secretkey, publicKeys) {\n  try {\n    // header part\n    const encryptionMethod = new Uint32Array([0])\n    const sessionKey = crypto.randomBytes(32)\n    const typeArray = []\n    const encPacketDataContent = enc.make_packet_data_enc(encryptionMethod, sessionKey)\n    typeArray.push(encPacketDataContent)\n    const headerPackets = enc.header_encrypt(typeArray, secretkey, publicKeys)\n    const serializedData = enc.serialize(headerPackets[0], headerPackets[1], headerPackets[2], headerPackets[3])\n    return [serializedData, sessionKey]\n  } catch (e) {\n    console.trace('Header Encryption not possible.')\n  }\n}\n\nexports.encHeaderEdit = async function (secretkey, publicKeys, editlist) {\n  try {\n    // header part\n    const encryptionMethod = new Uint32Array([0])\n    const sessionKey = crypto.randomBytes(32)\n    const serializedData = await enc.encryption_edit(editlist, encryptionMethod, sessionKey, publicKeys, secretkey)\n    return [serializedData, sessionKey]\n  } catch (e) {\n    console.trace('Header Encryption not possible.')\n  }\n}\n\nexports.pureEncryption = function (chunk, key) {\n  const algorithm = 'chacha20-poly1305'\n  const initVector = crypto.randomBytes(12)\n  const cipher = crypto.createCipheriv(algorithm, key, initVector)\n  const encryptedResult = Buffer.concat([initVector, cipher.update(chunk), cipher.final(), cipher.getAuthTag()])\n  const x = new Uint8Array(encryptedResult)\n  return x\n}\n\n/**\n * Function to create the encryption package\n * @param {*} encryptionMethode => which method is used for encryption (only chacha20poly1305 implemented)\n * @param {*} sessionKey => key to decrypt the input data\n * @returns encryption package as Uint8array\n */\nexports.make_packet_data_enc = function (encryptionMethode, sessionKey) {\n  try {\n    const uint8EncMethod = new Uint8Array(encryptionMethode.buffer)\n    const uint8TypeData = new Uint8Array(PacketTypeDataEnc.buffer)\n    const encPacketDataUint8 = new Uint8Array(uint8EncMethod.length + uint8TypeData.length + sessionKey.length)\n    encPacketDataUint8.set(uint8TypeData)\n    encPacketDataUint8.set(uint8EncMethod, uint8TypeData.length)\n    encPacketDataUint8.set(sessionKey, uint8EncMethod.length + uint8TypeData.length)\n    return encPacketDataUint8\n  } catch (e) {\n    console.trace('header encryption package could not be computed.')\n  }\n}\n\n/**\n * Function to compute encrypted headerpackages\n * @param {*} headerContent => List of encrypted data package and if there edit package\n * @param {*} seckey => seckret the of the uploading person\n * @param {*} pubkeys => List of public keys of the persons getting access to the data\n * @returns => List of encryption method, public key of the uploading person, nonce, encrypted headerpackages and sharedkey for decryption\n */\nexports.header_encrypt = function (headerContent, seckey, pubkeys) {\n  try {\n    // const nonce = crypto.randomBytes(12)\n    const initVector = crypto.randomBytes(12)\n    const k = x25519.generateKeyPairFromSeed(seckey)\n    let sharedkey\n    const encryptedHeader = []\n    const uint8Data = new Uint8Array(PacketTypeDataEnc.buffer)\n    let encrMethod\n    let d = 0\n    for (let i = 0; i < pubkeys.length; i++) {\n      const tuple = []\n      for (let j = 0; j < headerContent.length; j++) {\n        if (helperfunction.equal(headerContent[j].subarray(0, 4), uint8Data) === true && d === 0) {\n          encrMethod = [headerContent[j][4], headerContent[j][5], headerContent[j][6], headerContent[j][7]].join('')\n          d++\n        }\n        const dh = x25519.sharedKey(seckey, pubkeys[i])\n        const uint8Blake2b = new Uint8Array(dh.length + pubkeys[0].length + pubkeys[i].length)\n        uint8Blake2b.set(dh)\n        uint8Blake2b.set(pubkeys[i], dh.length)\n        uint8Blake2b.set(k.publicKey, dh.length + pubkeys[i].length)\n        const blake2b = new Blake2b.BLAKE2b()\n        blake2b.update(uint8Blake2b)\n        const uint8FromBlake2b = blake2b.digest()\n        sharedkey = uint8FromBlake2b.subarray(0, 32)\n        const algorithm = 'chacha20-poly1305'\n        const cipher = crypto.createCipheriv(algorithm, sharedkey, initVector)\n        const encryptedResult = Buffer.concat([cipher.update(headerContent[j]), cipher.final(), cipher.getAuthTag()])\n        const x = new Uint8Array(encryptedResult)\n        tuple.push(x)\n      }\n      encryptedHeader.push(tuple)\n    }\n    const ke = k.publicKey\n    return [encrMethod, ke, initVector, encryptedHeader, sharedkey]\n  } catch (e) {\n    console.trace('header could not be encrypted.')\n  }\n}\n\n/**\n * Function to complete the header according to crypt4gh format\n * @param {*} methode => encryption method (only chacha20poly1305)\n * @param {*} wPubkey => public key of the uploading person\n * @param {*} nonce => nonce used for encryption\n * @param {*} packets => List of encrypted header packages\n * @returns => Uint8array containing the complete crypt4gh format header\n */\nexports.serialize = function (methode, wPubkey, nonce, packets) {\n  try {\n    if (Array.isArray(packets[0])) {\n      packets = [].concat(...packets)\n    }\n    // erstellen des uersten headerteils -- magicbytestring, version, packetcount\n    const packetCountUint32 = new Uint32Array([packets.length])\n    const packetCountBuffer = packetCountUint32.buffer\n    const uint8PacketCount = new Uint8Array(packetCountBuffer)\n    const versionUint32 = new Uint32Array([1])\n    const versionBuffer = versionUint32.buffer\n    const uint8Version = new Uint8Array(versionBuffer)\n    const headerArray = new Uint8Array(uint8PacketCount.length + uint8Version.length + magicBytestring.length)\n    headerArray.set(magicBytestring)\n    headerArray.set(uint8Version, magicBytestring.length)\n    headerArray.set(uint8PacketCount, magicBytestring.length + uint8Version.length)\n    // erstellen des inneren header teils -- packet lnge, encmethode, wpubkey,nonce,encdata,mac\n    let packetLength = 0\n    const allPackets = []\n    for (let i = 0; i < packets.length; i++) {\n      const packetL = new Uint32Array([packets[i].length + methode.length + wPubkey.length + nonce.length + 4])\n      const packetLBuffer = packetL.buffer\n      const packetLUint8 = new Uint8Array(packetLBuffer)\n      const packetUint8 = new Uint8Array(packetLUint8.length + methode.length + wPubkey.length + packets[i].length + nonce.length)\n      packetUint8.set(packetLUint8)\n      packetUint8.set(methode, packetLUint8.length)\n      packetUint8.set(wPubkey, packetLUint8.length + methode.length)\n      packetUint8.set(nonce, packetLUint8.length + methode.length + wPubkey.length)\n      packetUint8.set(packets[i], packetLUint8.length + methode.length + wPubkey.length + nonce.length)\n      allPackets.push(packetUint8)\n      packetLength = packetLength + packetUint8.length\n    }\n    // header bestandteile zusammenfgen\n    let position = headerArray.length\n    const completeHeader = new Uint8Array(headerArray.length + packetLength)\n    completeHeader.set(headerArray)\n    for (let i = 0; i < allPackets.length; i++) {\n      completeHeader.set(allPackets[i], position)\n      position = position + allPackets[i].length\n    }\n    return completeHeader\n  } catch (e) {\n    console.trace('Encrypted header could not be completed.')\n  }\n}\n\n/**\n * Function to compute the complete header if an edit list or multiple edit lists are given\n * @param {*} editList => one or two dimensional array depends on whether one ore more edit lists are given\n * @param {*} encryptionMethod => encryption method (only chacha20poly1305)\n * @param {*} sessionKey => key used to encrypt the input data\n * @param {*} publicKeys => List of public keys of the persons getting access to the data\n * @param {*} secretkey => secret key of the uploading person\n * @param {*} type_array => contains the encryption package and the edit package\n * @returns => Uint8array containing the complete crypt4gh format header\n */\nexports.encryption_edit = async function (editList, encryptionMethod, sessionKey, publicKeys, secretkey) {\n  try {\n    const typeArray = []\n    if (Array.isArray(editList[0]) === true) {\n      const editPackets = enc.make_packet_edit_lists(editList)\n      const encPacketDataContent = enc.make_packet_data_enc(encryptionMethod, sessionKey)\n      if (editPackets.length === publicKeys.length) {\n        const headerPackets = enc.header_encrypt_multi_edit(editPackets, encPacketDataContent, secretkey, publicKeys)\n        const serializedData = enc.serialize(headerPackets[0], headerPackets[1], headerPackets[2], headerPackets[3])\n        return [serializedData, 0]\n      }\n    } else {\n      const editPacket = enc.make_packet_edit_list(editList)\n      const encPacketDataContent = enc.make_packet_data_enc(encryptionMethod, sessionKey)\n      typeArray.push(encPacketDataContent, editPacket)\n      const headerPackets = enc.header_encrypt(typeArray, secretkey, publicKeys)\n      const serializedData = enc.serialize(headerPackets[0], headerPackets[1], headerPackets[2], headerPackets[3])\n      return [serializedData, 1]\n    }\n  } catch (e) {\n    console.trace('Header including edit package could not be computed.')\n  }\n}\n\n/**\n * Function to compute the edit list package\n * @param {*} editList  => given edit list\n * @returns edit package (Uint8array)\n */\nexports.make_packet_edit_list = function (editList) {\n  try {\n    const bigEdits = []\n    for (let i = 0; i < editList.length; i++) {\n      bigEdits.push(BigInt(editList[i]))\n    }\n    const editUint64 = new BigUint64Array(bigEdits)\n    const editUint8 = new Uint8Array(editUint64.buffer)\n    const lenEditUint32 = new Uint32Array([editList.length])\n    const uint8Len = new Uint8Array(lenEditUint32.buffer)\n    const type = new Uint8Array(PacketTypeEditList.buffer)\n    const uint8Complete = new Uint8Array(type.length + uint8Len.length + editUint8.length)\n    uint8Complete.set(type)\n    uint8Complete.set(uint8Len, type.length)\n    uint8Complete.set(editUint8, uint8Len.length + type.length)\n    return uint8Complete\n  } catch (e) {\n    console.trace('edit list package could not be computed.')\n  }\n}\n\n/**\n * Function to compute edit packages if multiple edit lists are given\n * @param {*} editList => two dimensional array containing all given edit lists\n * @returns => edit packages (Array of Uint8arrays)\n */\nexports.make_packet_edit_lists = function (editList) {\n  try {\n    const allEdits = []\n    for (let i = 0; i < editList.length; i++) {\n      const bigEdits = []\n      for (let j = 0; j < editList[i].length; j++) {\n        bigEdits.push(BigInt(editList[i][j]))\n      }\n      const editUint64 = new BigUint64Array(bigEdits)\n      const editUint8 = new Uint8Array(editUint64.buffer)\n      const lenEditUint32 = new Uint32Array([editList[i].length])\n      const uint8Len = new Uint8Array(lenEditUint32.buffer)\n      const type = new Uint8Array(PacketTypeEditList.buffer)\n      const uint8Complete = new Uint8Array(type.length + uint8Len.length + editUint8.length)\n      uint8Complete.set(type)\n      uint8Complete.set(uint8Len, type.length)\n      uint8Complete.set(editUint8, uint8Len.length + type.length)\n      allEdits.push(uint8Complete)\n    }\n    return allEdits\n  } catch (e) {\n    console.trace('List of edit list packages could not be computed.')\n  }\n}\n\n/**\n * Function to encrypt the header packages if multiple edit lists are given\n * @param {*} editLists => Array of Uint8arrays containing the edit lists\n * @param {*} encryptionPaket => completed encryption package\n * @param {*} seckey => secret key of the uploading person\n * @param {*} pubkeys => List of public keys of the persons getting access to the data\n * @returns  List of encryption method, public key of the uploading person, nonce, encrypted headerpackages and sharedkey for decryption\n */\nexports.header_encrypt_multi_edit = function (editLists, encryptionPaket, seckey, pubkeys) {\n  try {\n    let headerContent = []\n    const initVector = crypto.randomBytes(12)\n    const k = x25519.generateKeyPairFromSeed(seckey)\n    let sharedkey\n    const encryptedHeader = []\n    const uint8Data = new Uint8Array([0, 0, 0, 0])\n    let encrMethod\n    for (let i = 0; i < pubkeys.length; i++) {\n      headerContent = [encryptionPaket, editLists[i]]\n      const tuple = []\n      for (let j = 0; j < headerContent.length; j++) {\n        if (helperfunction.equal(headerContent[j].subarray(0, 4), uint8Data) === true) {\n          encrMethod = new Uint8Array([headerContent[0][4], headerContent[0][5], headerContent[0][6], headerContent[0][7]])\n        }\n        const dh = x25519.sharedKey(seckey, pubkeys[i])\n        const uint8Blake2b = new Uint8Array(dh.length + k.publicKey.length + pubkeys[i].length)\n        uint8Blake2b.set(dh)\n        uint8Blake2b.set(pubkeys[i], dh.length)\n        uint8Blake2b.set(k.publicKey, dh.length + pubkeys[i].length)\n        const blake2b = new Blake2b.BLAKE2b()\n        blake2b.update(uint8Blake2b)\n        const uint8FromBlake2b = blake2b.digest()\n        sharedkey = uint8FromBlake2b.subarray(0, 32)\n        const algorithm = 'chacha20-poly1305'\n        const cipher = crypto.createCipheriv(algorithm, sharedkey, initVector)\n        const encryptedResult = Buffer.concat([initVector, cipher.update(headerContent[j]), cipher.final(), cipher.getAuthTag()])\n        tuple.push(encryptedResult)\n      }\n      encryptedHeader.push(tuple)\n    }\n    const ke = k.publicKey\n    return [encrMethod, ke, initVector, encryptedHeader]\n  } catch (e) {\n    console.trace('Header for encryption with mulitple edit lists could not be computed.')\n  }\n}\n\n\n//# sourceURL=webpack://crypt4gh_js/./src/encryption.js?");

/***/ }),

/***/ "./src/helper functions.js":
/*!*********************************!*\
  !*** ./src/helper functions.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Function to compute byte representation from string\n * @param {*} str =>input string\n * @returns => string in byte representation\n */\nexports.string2byte = function (str) {\n  try {\n    const result = new Uint8Array(str.length)\n    for (let i = 0; i < str.length; i++) {\n      result[i] = str.charCodeAt(i)\n    }\n    return result\n  } catch (e) {\n    console.trace('conversion not possible')\n  }\n}\n\n/**\n   * Function to compare Int8Arrays\n   * @param {*} buf1 => first buffer to  compare\n   * @param {*} buf2 => second buffer to compare\n   * @returns true if buf1 and buf2 are equal\n   */\nexports.equal = function (buf1, buf2) {\n  try {\n    if (buf1.byteLength !== buf2.byteLength) return false\n    const dv1 = new Int8Array(buf1)\n    const dv2 = new Int8Array(buf2)\n    for (let i = 0; i !== buf1.byteLength; i++) {\n      if (dv1[i] !== dv2[i]) return false\n    }\n    return true\n  } catch (e) {\n    console.trace('comparing not possible.')\n  }\n}\n\n/**\n * Function to compute base64 to ArrayBuffer\n * @param {*} base64 => input string\n * @returns => Uint8array\n */\nexports.base64ToArrayBuffer = function (base64) {\n  try {\n    const binaryString = atob(base64)\n    const bytes = new Uint8Array(binaryString.length)\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i)\n    }\n    return bytes\n  } catch (e) {\n    console.trace('conversion not possible.')\n  }\n}\n\n\n//# sourceURL=webpack://crypt4gh_js/./src/helper_functions.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const keygen = __webpack_require__(/*! ./keygen */ \"./src/keygen.js\")\nconst keyfiles = __webpack_require__(/*! ./check_keyfiles */ \"./src/check_keyfiles.js\")\nconst encryption = __webpack_require__(/*! ./encryption */ \"./src/encryption.js\")\nconst decryption = __webpack_require__(/*! ./decryption */ \"./src/decryption.js\")\nconst reeencryption = __webpack_require__(/*! ./reeencryption */ \"./src/reeencryption.js\")\nconst rearrangment = __webpack_require__(/*! ./rearrange */ \"./src/rearrange.js\")\nconst checkFileformat = __webpack_require__(/*! ./check_fileformat */ \"./src/check_fileformat.js\")\n\n// Decryption\n\ndocument.getElementById('input').addEventListener('change', function (e) {\n  const file = document.getElementById('input').files[0]\n  const file2 = document.getElementById('input').files[1]\n  const password = document.getElementById('psw').value\n  const blocks = document.getElementById('block').value;\n  (async () => {\n    const seckeyFile = await file.text()\n    const keys = await keyfiles.encryption_keyfiles([seckeyFile], password)\n    const fileContents = document.getElementById('filecontents')\n    fileContents.innerText = keys\n    /*\n    const block = blocks.split(',')\n    const fileContents = document.getElementById('filecontents')\n    const keys = await keyfiles.encryption_keyfiles([seckeyFile], password)\n    const plaintext = await decryption.pureDecryption(file2, keys[0], block)\n    fileContents.innerText = plaintext */\n  })()\n})\n\n// KeyGen\nconst button = document.getElementById('submit')\nbutton.addEventListener('click', async function (event) {\n  const password = await document.getElementById('psw2').value\n  const result = keygen.keygen(password)\n  const erg = await result\n  const pubkey = document.getElementById('pubkeyfile')\n  pubkey.innerText = erg[1]\n  const seckey = document.getElementById('seckeyfile')\n  seckey.innerText = erg[0]\n})\n\n\n//# sourceURL=webpack://crypt4gh_js/./src/index.js?");

/***/ }),

/***/ "./src/keygen.js":
/*!***********************!*\
  !*** ./src/keygen.js ***!
  \***********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const helperfunction = __webpack_require__(/*! ./helper functions.js */ \"./src/helper functions.js\")\nconst generateKeyPair = __webpack_require__(/*! @stablelib/x25519 */ \"./node_modules/@stablelib/x25519/lib/x25519.js\")\nconst scrypt = __webpack_require__(/*! scrypt-js */ \"./node_modules/scrypt-js/scrypt.js\")\nconst keygen = __webpack_require__(/*! ./keygen.js */ \"./src/keygen.js\")\nconst crypto = __webpack_require__(/*! crypto */ \"?fe02\")\n\nconst magicBytestring = helperfunction.string2byte('c4gh-v1')\n// without passphrase\nconst kdfNoneBestring = helperfunction.string2byte('none')\nconst chiperNoneBytestring = helperfunction.string2byte('none')\n// with pasphrase\nconst kdfScript = helperfunction.string2byte('scrypt')\nconst chiperChacha = helperfunction.string2byte('chacha20_poly1305')\n\n/**\n * Main function for key generation\n * @param {*} pasphrase => optional parameter, password (string)\n * @returns => List of secret key content and public key content\n */\nexports.keygen = async function (pasphrase) {\n  try {\n    const keys = generateKeyPair.generateKeyPair()\n    const pubkeyFile = keygen.create_pubkey(keys.publicKey)\n    const seckeyFile = await keygen.create_seckey(keys.secretKey, pasphrase)\n    return [seckeyFile, pubkeyFile]\n  } catch (e) {\n    console.trace('Key generation not possible.')\n  }\n}\n\n/**\n * Function to create public key contents\n * @param {*} pubkey => public key (Uint8array of length 32)\n * @returns => pubkey content as string\n */\nexports.create_pubkey = function (pubkey) {\n  try {\n    const b64 = btoa(String.fromCharCode.apply(null, pubkey))\n    return '-----BEGIN CRYPT4GH PUBLIC KEY-----\\n' + b64 + '\\n-----END CRYPT4GH PUBLIC KEY-----\\n'\n  } catch (e) {\n    console.trace('Pubkey generation not possible.')\n  }\n}\n\n/**\n * Function to create secret key contents\n * @param {*} seckey => secret key (Uint8array of length 32)\n * @param {*} passphrase => optional parameter, string to encrypt secret key\n * @returns => seckey content as string\n */\nexports.create_seckey = async function (seckey, passphrase) {\n  try {\n    if (passphrase !== '') {\n      const salt = crypto.randomBytes(16)\n      const saltround = new Uint8Array(4 + salt.length)\n      saltround.set([0, 0, 0, 0])\n      saltround.set(salt, 4)\n      const N = 16384; const r = 8; const p = 1\n      const dklen = 32\n      const keyPrmoise = scrypt.scrypt(helperfunction.string2byte(passphrase), salt, N, r, p, dklen)\n      const key = keyPrmoise.then(function (result) {\n        const nonce = crypto.randomBytes(12)\n        const algorithm = 'chacha20-poly1305'\n        const cipher = crypto.createCipheriv(algorithm, result, nonce)\n        const encryptedResult = Buffer.concat([cipher.update(seckey), cipher.final(), cipher.getAuthTag()])\n        const x = new Uint8Array(encryptedResult)\n        const fullUint8 = new Uint8Array(magicBytestring.length + kdfScript.length + chiperChacha.length + x.length + 8 + nonce.length + saltround.length)\n        fullUint8.set(magicBytestring)\n        fullUint8.set([0, 6], magicBytestring.length)\n        fullUint8.set(kdfScript, magicBytestring.length + 2)\n        fullUint8.set([0, 20], magicBytestring.length + kdfScript.length + 2)\n        fullUint8.set(saltround, magicBytestring.length + kdfScript.length + 4)\n        fullUint8.set([0, 17], magicBytestring.length + kdfScript.length + saltround.length + 4)\n        fullUint8.set(chiperChacha, magicBytestring.length + kdfScript.length + saltround.length + 6)\n        fullUint8.set([0, 12 + x.length], magicBytestring.length + kdfScript.length + chiperChacha.length + saltround.length + 6)\n        fullUint8.set(nonce, magicBytestring.length + kdfScript.length + chiperChacha.length + saltround.length + 8)\n        fullUint8.set(x, magicBytestring.length + kdfScript.length + chiperChacha.length + nonce.length + saltround.length + 8)\n        const b64 = btoa(String.fromCharCode.apply(null, fullUint8))\n        return '-----BEGIN CRYPT4GH PRIVATE KEY-----\\n' + b64 + '\\n-----END CRYPT4GH PRIVATE KEY-----\\n'\n      })\n      const a = await key\n      return a\n    } else {\n      const fullUint8 = new Uint8Array(magicBytestring.length + kdfNoneBestring.length + chiperNoneBytestring.length + seckey.length + 6)\n      fullUint8.set(magicBytestring)\n      fullUint8.set([0, 4], magicBytestring.length)\n      fullUint8.set(kdfNoneBestring, magicBytestring.length + 2)\n      fullUint8.set([0, 4], magicBytestring.length + kdfNoneBestring.length + 2)\n      fullUint8.set(chiperNoneBytestring, magicBytestring.length + kdfNoneBestring.length + 4)\n      fullUint8.set([0, 32], magicBytestring.length + kdfNoneBestring.length + chiperNoneBytestring.length + 4)\n      fullUint8.set(seckey, magicBytestring.length + kdfNoneBestring.length + chiperNoneBytestring.length + 6)\n      const b64 = btoa(String.fromCharCode.apply(null, fullUint8))\n      return '-----BEGIN CRYPT4GH PRIVATE KEY-----\\n' + b64 + '\\n-----END CRYPT4GH PRIVATE KEY-----\\n'\n    }\n  } catch (e) {\n    console.trace('Secret key generation not possible.')\n  }\n}\n\n\n//# sourceURL=webpack://crypt4gh_js/./src/keygen.js?");

/***/ }),

/***/ "./src/rearrange.js":
/*!**************************!*\
  !*** ./src/rearrange.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const enc = __webpack_require__(/*! ./encryption */ \"./src/encryption.js\")\nconst dec = __webpack_require__(/*! ./decryption */ \"./src/decryption.js\")\nconst rea = __webpack_require__(/*! ./rearrange */ \"./src/rearrange.js\")\n\nconst SEGMENT_SIZE = 65536\nconst PacketTypeDataEnc = '0000'\nconst PacketTypeEditList = '1000'\n\nexports.rearrange = async function (infile, seckey, pubkey, editlist) {\n  try {\n    const fullEnc = []\n    const header = await infile.subarray(0, 10000)\n    const headerPackets = dec.parse(header)\n    const decryptedPackets = dec.decrypt_header(headerPackets[0], seckey)\n    const rearranged = rearrangement(decryptedPackets, editlist, headerPackets, pubkey, seckey, fullEnc, infile)\n    return rearranged\n  } catch (e) {\n    console.trace('Data could not be rearranged.')\n  }\n}\n\nexports.streamRearrange = async function (header, seckey, pubkey, editlist) {\n  const headerPackets = dec.parse(header)\n  const decryptedPackets = dec.decrypt_header(headerPackets[0], seckey)\n  const sessionk = decryptedPackets[0][0].subarray(8)\n  const newEditPacket = await headerRearrange(decryptedPackets[0], editlist, headerPackets[1].length, pubkey, seckey, sessionk)\n  return [newEditPacket[0], headerPackets[2]]\n}\n\nasync function headerRearrange (decPackets, editlist, inputlnge, pubkeys, seckey, key) {\n  try {\n    const encryptionMethod = new Uint32Array([0])\n    const partitionPacket = partitionPackets(decPackets)\n    // no editlist in old header\n    if (partitionPacket[1].length === 0) {\n      const encHeader = await enc.encryption_edit(editlist, encryptionMethod, key, pubkeys, seckey)\n      return encHeader\n    } else {\n      const oldEdit = partitionPacket[1][0]\n      const big64Oldedit = new BigUint64Array(oldEdit.buffer)\n      let b\n      const outOfRange = []\n      // new header with multiple editlists\n      if (Array.isArray(editlist[0]) === true) {\n        const multiEdit = await rearrHeaderMultiEdits(editlist, big64Oldedit, inputlnge, b, outOfRange, encryptionMethod, key, pubkeys, seckey)\n        return multiEdit\n      } else {\n        // new header with single edit list\n        const singleEdit = await rearrHeaderEdit(big64Oldedit, inputlnge, b, editlist, decPackets, seckey, pubkeys)\n        return singleEdit\n      }\n    }\n  } catch (e) {\n    console.trace('header could not be rearranged.')\n  }\n}\n\nfunction calculateLastEditOld (inputlnge, big, b) {\n  try {\n    let fit = 0\n    let counter = 0\n    while (fit <= inputlnge - 65564) {\n      fit = fit + 65564\n      counter++\n    }\n    if (fit < inputlnge) {\n      counter++\n    }\n    let sum = BigInt(0)\n    b = new BigUint64Array(big.length)\n    b.set(big.slice(1))\n    b.forEach(x => { sum += x })\n    const last = BigInt(inputlnge) - BigInt(counter * 28) - sum\n    b.set([last], big.length - 1)\n    return [b, big]\n  } catch (e) {\n    console.trace('old edit list could not be analysed.')\n  }\n}\n\nfunction calculaLastEditNew (inputlnge, editlist) {\n  try {\n    let sum = 0\n    let fit = 0\n    let counter = 0\n    while (fit <= inputlnge - 65564) {\n      fit = fit + 65564\n      counter++\n    }\n    if (fit < inputlnge) {\n      counter++\n    }\n    editlist.forEach(x => { sum += x })\n    editlist.push(inputlnge - counter * 28 - sum)\n    return editlist\n  } catch (e) {\n    console.trace('new edit list could not be analysed.')\n  }\n}\n\nexports.parts = function (edits) {\n  try {\n    let position = BigInt(0)\n    const allowed = []\n    for (let i = 0; i < edits.length; i = i + 2) {\n      const discard = edits[i]\n      position = position + BigInt(discard)\n      if (i + 1 < edits.length) {\n        const keep = BigInt(edits[i + 1])\n        allowed.push([position, position + keep])\n        position = position + BigInt(keep)\n      } else {\n        const keep = BigInt(edits[i + 1])\n        allowed.push([position, position + keep])\n      }\n    }\n    return allowed\n  } catch (e) {\n    console.trace('decryptable parts could not be computed.')\n  }\n}\n\nfunction checkParts (allowed, newEdit) {\n  try {\n    const checked = []\n    for (let i = 0; i < allowed.length; i++) {\n      let fits = 0\n      for (let j = 0; j < newEdit.length; j++) {\n        if (allowed[i][0] <= BigInt(newEdit[j][0]) && allowed[i][1] >= BigInt(newEdit[j][1])) {\n          checked.push(newEdit[j])\n          fits++\n        }\n      }\n      if (fits < 0) {\n        console.trace('unencryptable data')\n      }\n    }\n    return checked\n  } catch (e) {\n    console.trace('data acess could not be checked.')\n  }\n}\n\nfunction partitionPackets (packets) {\n  try {\n    const encPackets = []\n    const editPackets = []\n    for (let i = 0; i < packets.length; i++) {\n      const packetType = [packets[i][0], packets[i][1], packets[i][2], packets[i][3]].join('')\n      if (packetType === PacketTypeDataEnc) {\n        encPackets.push(packets[i].subarray(4))\n      } else if (packetType === PacketTypeEditList) {\n        editPackets.push(packets[i].subarray(8))\n      } else {\n        throw Error('Invalid packet type')\n      }\n    }\n    return [encPackets, editPackets]\n  } catch (e) {\n    console.trace('Packages could not be partitionated.')\n  }\n}\n\nasync function rearrangement (decryptedPackets, editlist, headerPackets, pubkey, seckey, fullEnc, infile) {\n  try {\n    const sessionk = decryptedPackets[0][0].subarray(8)\n    const newEditPacket = await headerRearrange(decryptedPackets[0], editlist, headerPackets[1].length, pubkey, seckey, sessionk)\n    if (newEditPacket) {\n      fullEnc.push(newEditPacket[0])\n      const chunksize = SEGMENT_SIZE\n      let offset = headerPackets[2]\n      while (offset < infile.length) {\n        const chunkfile = await infile.subarray(offset, offset + chunksize)\n        fullEnc.push(chunkfile)\n        offset += chunksize\n      }\n      return fullEnc\n    }\n  } catch (e) {\n    console.trace('Rearrangment could not be computed.')\n  }\n}\n\nasync function rearrHeaderMultiEdits (editlist, big64Oldedit, inputlnge, b, outOfRange, encryptionMethod, key, pubkeys, seckey) {\n  for (let i = 0; i < editlist.length; i++) {\n    if ((big64Oldedit.length - 1) % 2 !== 0) {\n      const lastEdit = calculateLastEditOld(inputlnge, big64Oldedit, b)\n      b = lastEdit[0]\n      big64Oldedit = lastEdit[1]\n    } else {\n      b = big64Oldedit.slice(1)\n    }\n    if ((editlist[i].length) % 2 !== 0) {\n      editlist[i] = calculaLastEditNew(inputlnge, editlist[i])\n    }\n    // Berechnung, bereiche der beiden editlisten\n    const allowed = rea.parts(b)\n    const newEdit = rea.parts(editlist[i])\n    // Berechne, ob Bereiche ineinander passen\n    const checked = checkParts(allowed, newEdit)\n    if (checked.length === newEdit.length) {\n      for (let i = 0; i < checked.length; i++) {\n        if (i === 0) {\n          outOfRange.push(0)\n        }\n        if (checked[i][0] !== newEdit[i][0] || checked[i][1] !== newEdit[i][1]) {\n          outOfRange.push(1)\n        }\n      }\n    }\n  }\n  if (!outOfRange.includes(1)) {\n    const s = await enc.encryption_edit(editlist, encryptionMethod, key, pubkeys, seckey)\n    return s\n  }\n}\n\nasync function rearrHeaderEdit (big64Oldedit, inputlnge, b, editlist, decPackets, seckey, pubkeys) {\n  // abfragen ob die alte und/oder neue editliste ungerade sind/ist\n  if ((big64Oldedit.length - 1) % 2 !== 0) {\n    const lastEdit = calculateLastEditOld(inputlnge, big64Oldedit, b)\n    b = lastEdit[0]\n    big64Oldedit = lastEdit[1]\n  } else {\n    b = big64Oldedit.slice(1)\n  }\n  if ((editlist.length) % 2 !== 0) {\n    editlist = calculaLastEditNew(inputlnge, editlist)\n  }\n  // Berechnung, bereiche der beiden editlisten\n  const allowed = rea.parts(b)\n  const newEdit = rea.parts(editlist)\n  // Berechne, ob Bereiche ineinander passen\n  const checked = checkParts(allowed, newEdit)\n  let unallowedEdit\n  if (checked.length === newEdit.length) {\n    for (let i = 0; i < checked.length; i++) {\n      if (i === 0) {\n        unallowedEdit = 0\n      }\n      if (checked[i][0] !== newEdit[i][0] || checked[i][1] !== newEdit[i][1]) {\n        unallowedEdit = 1\n      }\n    }\n    if (unallowedEdit === 0) {\n      const newEditPacket = enc.make_packet_edit_list(editlist)\n      const encr = enc.header_encrypt([decPackets[0], newEditPacket], seckey, pubkeys)\n      const serializedData = enc.serialize(encr[0], encr[1], encr[2], encr[3])\n      return [serializedData, 1]\n    }\n  }\n}\n\n\n//# sourceURL=webpack://crypt4gh_js/./src/rearrange.js?");

/***/ }),

/***/ "./src/reeencryption.js":
/*!******************************!*\
  !*** ./src/reeencryption.js ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const x25519 = __webpack_require__(/*! @stablelib/x25519 */ \"./node_modules/@stablelib/x25519/lib/x25519.js\")\nconst enc = __webpack_require__(/*! ./encryption */ \"./src/encryption.js\")\nconst dec = __webpack_require__(/*! ./decryption */ \"./src/decryption.js\")\n\nconst SEGMENTSIZE = 65536\nconst newKey = x25519.generateKeyPair()\n\n/**\n * Function to reencrypt an already crypt4gh encrypted file. (change header to make it accessable for other persons)\n * @param {*} encryptedData => crypt4gh file content (Uint8array)\n * @param {*} keysPub => List of public keys (Array of Uint8arrays)\n * @param {*} keySec => uploaders secret key (Uint8array)\n * @returns => Array of Uint8arrays containing new crypt4gh file\n */\nexports.reencrypt = async function * (encryptedData, keysPub, keySec) {\n  try {\n    // Decrypt and Reencrypt header of infile\n    const header = await encryptedData.subarray(0, 10000)\n    const headerPackets = dec.parse(header)\n    const decryptedPackets = dec.decrypt_header(headerPackets[0], keySec)\n    const headers = [decryptedPackets[0][0]]\n    headers.push(decryptedPackets[0][0])\n    keysPub.unshift(newKey.publicKey)\n    const encr = enc.header_encrypt(headers, newKey.secretKey, keysPub)\n    const serializedData = enc.serialize(encr[0], keysPub[0], encr[2], encr[3])\n    const chunksize = SEGMENTSIZE\n    let offset = headerPackets[2]\n    while (offset < encryptedData.length) {\n      if (offset === 0) {\n        const chunkfile = await encryptedData.subarray(offset, offset + chunksize)\n        const nonceEnc = new Uint8Array(serializedData.length + chunkfile.length)\n        nonceEnc.set(serializedData)\n        nonceEnc.set(chunkfile, serializedData.length)\n        yield await Promise.resolve(nonceEnc)\n        offset += chunksize\n      } else {\n        const chunkfile = await encryptedData.subarray(offset, offset + chunksize)\n        yield await Promise.resolve(chunkfile)\n        offset += chunksize\n      }\n    }\n  } catch (e) {\n    console.trace('Reeencryption not possible.')\n  }\n}\n\nexports.streamReencryptHeader = function (header, keysPub, keySec) {\n  const headerPackets = dec.parse(header)\n  const decryptedPackets = dec.decrypt_header(headerPackets[0], keySec)\n  const headers = [decryptedPackets[0][0]]\n  headers.push(decryptedPackets[0][0])\n  keysPub.unshift(newKey.publicKey)\n  const encr = enc.header_encrypt(headers, newKey.secretKey, keysPub)\n  const serializedData = enc.serialize(encr[0], keysPub[0], encr[2], encr[3])\n  return [serializedData, headerPackets[2]]\n}\n\n\n//# sourceURL=webpack://crypt4gh_js/./src/reeencryption.js?");

/***/ }),

/***/ "?25ed":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://crypt4gh_js/crypto_(ignored)?");

/***/ }),

/***/ "?fe02":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://crypt4gh_js/crypto_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;